
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Numerical Analysis Modules in gvar &#8212; gvar 12.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/pyramid.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Case Study: Numerical Analysis — Pendulum Clock" href="case-pendulum.html" />
    <link rel="prev" title="gvar.dataset - Random Data Sets" href="gvar_dataset.html" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head><body>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="case-pendulum.html" title="Case Study: Numerical Analysis — Pendulum Clock"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="gvar_dataset.html" title="gvar.dataset - Random Data Sets"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">gvar 12.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Numerical Analysis Modules in <code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar</span></code></a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="numerical-analysis-modules-in-gvar">
<span id="id1"></span><h1>Numerical Analysis Modules in <a class="reference internal" href="gvar.html#module-gvar" title="gvar: Correlated Gaussian random variables."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar</span></code></a><a class="headerlink" href="#numerical-analysis-modules-in-gvar" title="Permalink to this heading">¶</a></h1>
<p><a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code></a>s can be used in many numerical algorithms, to propagates errors
through the algorithm. A code that is written in pure Python is likely to
work well with <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code></a>s, perhaps with minor modifications.
Here we describe some sample numerical codes, included in
<a class="reference internal" href="gvar.html#module-gvar" title="gvar: Correlated Gaussian random variables."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar</span></code></a>, that have been adapted
to work with <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code></a>s, as well as with <code class="docutils literal notranslate"><span class="pre">float</span></code>s.
More examples will follow with time.</p>
<p>The sub-modules included here are:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#module-gvar.cspline" title="gvar.cspline: Cubic splines."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar.cspline</span></code></a> — cubic splines for 1-d data.</p></li>
<li><p><a class="reference internal" href="#module-gvar.linalg" title="gvar.linalg: Basic linear algebra."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar.linalg</span></code></a> — basic linear algebra.</p></li>
<li><dl class="simple">
<dt><a class="reference internal" href="#module-gvar.ode" title="gvar.ode: Ordinary differential equations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar.ode</span></code></a> — integration of systems of ordinary differential equations;</dt><dd><p><a class="reference internal" href="#integral"><span class="std std-ref">one-dimensional integrals</span></a>.</p>
</dd>
</dl>
</li>
<li><p><a class="reference internal" href="#module-gvar.powerseries" title="gvar.powerseries: Power series arithmetic and evaluation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar.powerseries</span></code></a> — power series representation of functions.</p></li>
<li><p><a class="reference internal" href="#module-gvar.root" title="gvar.root: Roots (zeros) of one-dimensional functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar.root</span></code></a> — root-finding for one-dimensional functions.</p></li>
</ul>
</div></blockquote>
<span class="target" id="module-gvar.cspline"></span><section id="cubic-splines">
<h2>Cubic Splines<a class="headerlink" href="#cubic-splines" title="Permalink to this heading">¶</a></h2>
<p>Module <a class="reference internal" href="#module-gvar.cspline" title="gvar.cspline: Cubic splines."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar.cspline</span></code></a> implements a class for smoothing and/or
interpolating one-dimensional data using cubic splines:</p>
<dl class="py class">
<dt class="sig sig-object py" id="gvar.cspline.CSpline">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">gvar.cspline.</span></span><span class="sig-name descname"><span class="pre">CSpline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xknot</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yknot</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deriv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(None,</span> <span class="pre">None)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extrap_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'steffen'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.cspline.CSpline" title="Permalink to this definition">¶</a></dt>
<dd><p>Cubic spline approximation to a function.</p>
<p>Given <code class="docutils literal notranslate"><span class="pre">N</span></code> values of a function <code class="docutils literal notranslate"><span class="pre">yknot[i]</span></code> at <code class="docutils literal notranslate"><span class="pre">N</span></code> points
<code class="docutils literal notranslate"><span class="pre">xknot[i]</span></code> for <code class="docutils literal notranslate"><span class="pre">i=0..N-1</span></code> (the <em>knots</em> of the spline),
the code</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">gvar.cspline</span> <span class="kn">import</span> <span class="n">CSpline</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">CSpline</span><span class="p">(</span><span class="n">xknot</span><span class="p">,</span> <span class="n">yknot</span><span class="p">)</span>
</pre></div>
</div>
<p>defines a function <code class="docutils literal notranslate"><span class="pre">f</span></code> such that: a) <code class="docutils literal notranslate"><span class="pre">f(xknot[i])</span> <span class="pre">=</span> <span class="pre">yknot[i]</span></code>
for all <code class="docutils literal notranslate"><span class="pre">i</span></code>; and b) <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> and its first derivative are
continuous. Function <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> is a cubic polynomial
between the knots <code class="docutils literal notranslate"><span class="pre">xknot[i]</span></code> (determined from the values
and first derivatives at the adjacent knots).
Argument <code class="docutils literal notranslate"><span class="pre">x</span></code> in <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> is a number or an array
of numbers (any shape). Numbers can be replaced
by <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar.GVar</span></code></a> objects in <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">xknot</span></code>
and/or <code class="docutils literal notranslate"><span class="pre">yknot</span></code>.</p>
<p>Derivatives and integrals of the spline function are also
available:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">f.D(x)</span></code> — first derivative at <code class="docutils literal notranslate"><span class="pre">x</span></code>;</p>
<p><code class="docutils literal notranslate"><span class="pre">f.D2(x)</span></code> — second derivative at <code class="docutils literal notranslate"><span class="pre">x</span></code>;</p>
<p><code class="docutils literal notranslate"><span class="pre">f.D3(x)</span></code> — third derivative at <code class="docutils literal notranslate"><span class="pre">x</span></code>;</p>
<p><code class="docutils literal notranslate"><span class="pre">f.integ(x)</span></code> — integral from <code class="docutils literal notranslate"><span class="pre">xknot[0]</span></code> to <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</div></blockquote>
<p>The derivatives are increasingly unreliable with increasing order.</p>
<p>Splines can be used outside the range covered by the defining
<code class="docutils literal notranslate"><span class="pre">xknot</span></code> values. As this is often a bad idea, keyword parameter
<code class="docutils literal notranslate"><span class="pre">warn</span></code> can be set to <code class="docutils literal notranslate"><span class="pre">True</span></code> so that warnings are generated
if the spline is used out of range. This keyword is set
in the original constructor (<code class="docutils literal notranslate"><span class="pre">CSpline(x,</span> <span class="pre">y,</span> <span class="pre">warn=True)</span></code>) or in
calls to a <code class="xref py py-mod docutils literal notranslate"><span class="pre">CSpline</span></code> object (eg, <code class="docutils literal notranslate"><span class="pre">f.D(x,</span> <span class="pre">warn=True)</span></code>).
The spline value for an out-of-range point is calculated
using a polynomial whose value and derivatives match those of the spline
at the knot closest to the out-of-range point. The extrapolation
polynomial is cubic by default, but lower orders are specified by
setting parameter <code class="docutils literal notranslate"><span class="pre">extrap_order</span></code> to a (non-negative) integer
less than 3.</p>
<p>The first derivatives of <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> at the knots are determined
from the function values in the vicinity of the knot. The derivatives
at the endpoints (<code class="docutils literal notranslate"><span class="pre">xknot[0]</span></code> and <code class="docutils literal notranslate"><span class="pre">xknot[-1]</span></code> if the knots are
ordered) can be specified explicitly, if they are known:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">CSpline</span><span class="p">(</span><span class="n">xknot</span><span class="p">,</span> <span class="n">yknot</span><span class="p">,</span> <span class="n">deriv</span><span class="o">=</span><span class="p">[</span><span class="n">dydx_i</span><span class="p">,</span> <span class="n">dydx_f</span><span class="p">])</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">dydx_i</span></code> is the derivative at <code class="docutils literal notranslate"><span class="pre">xknot[0]</span></code> and <code class="docutils literal notranslate"><span class="pre">dydx_f</span></code>
is the derivative at <code class="docutils literal notranslate"><span class="pre">xknot[-1]</span></code>.</p>
<p>There are different types of spline available, selected with
keyword <code class="docutils literal notranslate"><span class="pre">alg</span></code>:</p>
<blockquote>
<div><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">alg='steffen'</span></code></dt><dd><p>Monotonic cubic spline that has quadratic precision
where the function is monotonic between knots. This is
the default algorithm.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">alg='cspline'</span></code></dt><dd><p>Cubic spline with continuous second derivatives <code class="docutils literal notranslate"><span class="pre">f''(x)</span></code>
(in addition to <code class="docutils literal notranslate"><span class="pre">f'(x)</span></code> and <code class="docutils literal notranslate"><span class="pre">f(x)</span></code>). Sets
<code class="docutils literal notranslate"><span class="pre">f''(x)</span></code> to zero at the endpoints (<em>natural</em> boundary
conditions) if the first derivatives have not been
specified there (using keyword <code class="docutils literal notranslate"><span class="pre">deriv</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">alg='pchip'</span></code></dt><dd><p>Monotonic cubic spline used in the <code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy</span></code>
function <code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.interpolate.PchipInterpolator</span></code>.
This algorithm is usually less accurate than <code class="docutils literal notranslate"><span class="pre">'steffen'</span></code>
where the function is smooth (and monotonic).</p>
</dd>
</dl>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">'cspline'</span></code> algorithm gives the smoothest interpolations
and the most accuracy for very smooth functions, but it tends
to overreact to abrupt jumps in the function, leading
to unrealistic oscillations around the jump. Monotonic
splines are guaranteed to be monotonic between knots and so
are unable to overshoot the input data in this way. (The
monotonic splines may not be monotonic in the first or last
intervals if derivatives are supplied for the endpoints,
using the <code class="docutils literal notranslate"><span class="pre">deriv</span></code> keyword. Also third derivatives (<code class="docutils literal notranslate"><span class="pre">f.D3(x)</span></code>)
are unreliable for monotonic splines.)</p>
<p>The algorithm is irrelevant when there are only two knots. In that case
the spline is linear if no derivatives are specified (using <code class="docutils literal notranslate"><span class="pre">deriv</span></code>),
quadratic if one or the other derivative is specified, or cubic
if both derivatives are specified.</p>
<p class="rubric">Examples</p>
<p>Typical usage is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gvar</span> <span class="k">as</span> <span class="nn">gv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xknot</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.78539816</span><span class="p">,</span> <span class="mf">1.57079633</span><span class="p">,</span> <span class="mf">2.35619449</span><span class="p">,</span> <span class="mf">3.14159265</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yknot</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.70710678</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.70710678</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">cspline</span><span class="o">.</span><span class="n">CSpline</span><span class="p">(</span><span class="n">xknot</span><span class="p">,</span> <span class="n">yknot</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mf">0.7</span><span class="p">),</span> <span class="n">f</span><span class="o">.</span><span class="n">D</span><span class="p">(</span><span class="mf">0.7</span><span class="p">),</span> <span class="n">f</span><span class="o">.</span><span class="n">integ</span><span class="p">(</span><span class="mf">0.7</span><span class="p">))</span>
<span class="go">0.644243383100598 0.7655924482958195 0.23496394264839268</span>
</pre></div>
</div>
<p>Here the <code class="docutils literal notranslate"><span class="pre">yknot</span></code> values were obtained by taking <code class="docutils literal notranslate"><span class="pre">sin(xknot)</span></code>.
Tabulating results from the spline together with the exact results
shows that this 5-knot spline gives a pretty good approximation
of the function <code class="docutils literal notranslate"><span class="pre">sin(x)</span></code>, as well as its derivatives and integral:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span>    <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>    <span class="n">f</span><span class="o">.</span><span class="n">D</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="n">f</span><span class="o">.</span><span class="n">D2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="n">f</span><span class="o">.</span><span class="n">integ</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">|</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="mi">1</span><span class="o">-</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="o">------------------------------------------------------------------</span>
<span class="mf">0.3</span>  <span class="mf">0.2951</span>  <span class="mf">0.9551</span>  <span class="o">-</span><span class="mf">0.2842</span> <span class="mf">0.0446</span>     <span class="o">|</span> <span class="mf">0.2955</span>  <span class="mf">0.9553</span>  <span class="mf">0.0447</span>
<span class="mf">0.5</span>  <span class="mf">0.4791</span>  <span class="mf">0.8793</span>  <span class="o">-</span><span class="mf">0.4737</span> <span class="mf">0.1222</span>     <span class="o">|</span> <span class="mf">0.4794</span>  <span class="mf">0.8776</span>  <span class="mf">0.1224</span>
<span class="mf">0.7</span>  <span class="mf">0.6442</span>  <span class="mf">0.7656</span>  <span class="o">-</span><span class="mf">0.6632</span> <span class="mf">0.2350</span>     <span class="o">|</span> <span class="mf">0.6442</span>  <span class="mf">0.7648</span>  <span class="mf">0.2352</span>
<span class="mf">0.9</span>  <span class="mf">0.7830</span>  <span class="mf">0.6176</span>  <span class="o">-</span><span class="mf">0.7891</span> <span class="mf">0.3782</span>     <span class="o">|</span> <span class="mf">0.7833</span>  <span class="mf">0.6216</span>  <span class="mf">0.3784</span>
<span class="mf">1.1</span>  <span class="mf">0.8902</span>  <span class="mf">0.4520</span>  <span class="o">-</span><span class="mf">0.8676</span> <span class="mf">0.5461</span>     <span class="o">|</span> <span class="mf">0.8912</span>  <span class="mf">0.4536</span>  <span class="mf">0.5464</span>
<span class="mf">1.3</span>  <span class="mf">0.9627</span>  <span class="mf">0.2706</span>  <span class="o">-</span><span class="mf">0.9461</span> <span class="mf">0.7319</span>     <span class="o">|</span> <span class="mf">0.9636</span>  <span class="mf">0.2675</span>  <span class="mf">0.7325</span>
<span class="mf">1.5</span>  <span class="mf">0.9974</span>  <span class="mf">0.0735</span>  <span class="o">-</span><span class="mf">1.0246</span> <span class="mf">0.9286</span>     <span class="o">|</span> <span class="mf">0.9975</span>  <span class="mf">0.07074</span> <span class="mf">0.9293</span>
</pre></div>
</div>
<p>Using the spline outside
the range covered by the knots is less good:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
<span class="go">1.7618635470106572</span>
</pre></div>
</div>
<p>The correct answer is 0.0, of course. Working just outside
the knot region is often fine, although it might be
a good idea to limit the order of the polynomial
used in such regions: for example, setting</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">cspline</span><span class="o">.</span><span class="n">CSpline</span><span class="p">(</span><span class="n">xknot</span><span class="p">,</span> <span class="n">yknot</span><span class="p">,</span> <span class="n">extrap_order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>implies that quadratic polynomials are used outside the spline range.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xknot</strong> (<em>1-d sequence</em>) – Location of the
spline’s knots, where the function values are
specified. The locations can be numbers of
<a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar.GVar</span></code></a> objects.</p></li>
<li><p><strong>yknot</strong> (<em>1-d sequence</em>) – Function values at
the locations specified by <code class="docutils literal notranslate"><span class="pre">xknot[i]</span></code>. The
values can be numbers or
<a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar.GVar</span></code></a> objects.</p></li>
<li><p><strong>deriv</strong> (<em>2-component sequence</em>) – Derivatives at initial
and final boundaries of the  region specified
by <code class="docutils literal notranslate"><span class="pre">xknot[i]</span></code>. The derivatives can be numbers or
<a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar.GVar</span></code></a> objects. Default value is <code class="docutils literal notranslate"><span class="pre">None</span></code>
for each boundary, which implies <em>natural</em> boundary
conditions (vanishing second derivative).</p></li>
<li><p><strong>extrap_order</strong> (<em>int</em>) – Order of polynomial used for
extrapolations outside of the spline range.
The polynomial is constructed from the spline’s
value and derivatives at the (nearest) knot of the
spline. The allowed range is <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">extrap_order</span> <span class="pre">&lt;=</span> <span class="pre">3</span></code>.
The default value is 3 although it is common practice
to use smaller values.</p></li>
<li><p><strong>warn</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, warnings are generated
when the spline function is called for <code class="docutils literal notranslate"><span class="pre">x</span></code> values that
fall outside of the original range of <code class="docutils literal notranslate"><span class="pre">xknot</span></code>s used to
define the spline. Default value is <code class="docutils literal notranslate"><span class="pre">False</span></code>,
which means out-of-range warnings are suppressed.</p></li>
<li><p><strong>alg</strong> (<em>str</em>) – Spline algorithm used, which is one of:
<code class="docutils literal notranslate"><span class="pre">'steffen'</span></code> (default), <code class="docutils literal notranslate"><span class="pre">'cspline'</span></code>, and
<code class="docutils literal notranslate"><span class="pre">'pchip'</span></code>. The first and last of these give
monotonic splines.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-gvar.linalg"></span></section>
<section id="linear-algebra">
<h2>Linear Algebra<a class="headerlink" href="#linear-algebra" title="Permalink to this heading">¶</a></h2>
<p>Module <a class="reference internal" href="#module-gvar.linalg" title="gvar.linalg: Basic linear algebra."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar.linalg</span></code></a> implements several methods for doing basic
linear algebra with matrices whose elements can be either numbers or
<a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code></a>s:</p>
<dl class="py method">
<dt class="sig sig-object py" id="gvar.linalg.det">
<span class="sig-prename descclassname"><span class="pre">linalg.</span></span><span class="sig-name descname"><span class="pre">det</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.linalg.det" title="Permalink to this definition">¶</a></dt>
<dd><p>Determinant of matrix <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>a</strong> – Two-dimensional, square matrix/array of numbers
and/or <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code></a>s.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Deterimant of the matrix.</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If matrix is not square and two-dimensional.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gvar.linalg.slogdet">
<span class="sig-prename descclassname"><span class="pre">linalg.</span></span><span class="sig-name descname"><span class="pre">slogdet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.linalg.slogdet" title="Permalink to this definition">¶</a></dt>
<dd><p>Sign and logarithm of determinant of matrix <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>a</strong> – Two-dimensional, square matrix/array of numbers
and/or <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code></a>s.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Tuple <code class="docutils literal notranslate"><span class="pre">(s,</span> <span class="pre">logdet)</span></code> where the determinant of matrix <code class="docutils literal notranslate"><span class="pre">a</span></code> is</dt><dd><p><code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">*</span> <span class="pre">exp(logdet)</span></code>.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If matrix is not square and two-dimensional.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gvar.linalg.inv">
<span class="sig-prename descclassname"><span class="pre">linalg.</span></span><span class="sig-name descname"><span class="pre">inv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.linalg.inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse of matrix <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>a</strong> – Two-dimensional, square matrix/array of numbers
and/or <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code></a>s.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The inverse of matrix <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If matrix is not square and two-dimensional.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gvar.linalg.solve">
<span class="sig-prename descclassname"><span class="pre">linalg.</span></span><span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.linalg.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Find <code class="docutils literal notranslate"><span class="pre">x</span></code> such that <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&#64;</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">b</span></code> for matrix <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – Two-dimensional, square matrix/array of numbers
and/or <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code></a>s.</p></li>
<li><p><strong>b</strong> – One-dimensional vector/array of numbers and/or
<a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code></a>s, or an array of such vectors.
Requires <code class="docutils literal notranslate"><span class="pre">b.shape[0]</span> <span class="pre">==</span> <span class="pre">a.shape[1]</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The solution <code class="docutils literal notranslate"><span class="pre">x</span></code> of <code class="docutils literal notranslate"><span class="pre">a.dot(x)</span> <span class="pre">=</span> <span class="pre">b</span></code>, which is equivalent
to <code class="docutils literal notranslate"><span class="pre">inv(a).dot(b)</span></code>.</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ValueError</strong> – If <code class="docutils literal notranslate"><span class="pre">a</span></code> is not square and two-dimensional.</p></li>
<li><p><strong>ValueError</strong> – If shape of <code class="docutils literal notranslate"><span class="pre">b</span></code> does not match that of <code class="docutils literal notranslate"><span class="pre">a</span></code>
    (that is <code class="docutils literal notranslate"><span class="pre">b.shape[0]</span> <span class="pre">!=</span> <span class="pre">a.shape[1]</span></code>).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gvar.linalg.lstsq">
<span class="sig-prename descclassname"><span class="pre">linalg.</span></span><span class="sig-name descname"><span class="pre">lstsq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weighted</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extrainfo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.linalg.lstsq" title="Permalink to this definition">¶</a></dt>
<dd><p>Least-squares solution <code class="docutils literal notranslate"><span class="pre">x</span></code> to <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&#64;</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">b</span></code> for <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code></a>s.</p>
<p>Here <code class="docutils literal notranslate"><span class="pre">x</span></code> is defined to be the solution that minimizes <code class="docutils literal notranslate"><span class="pre">||b</span> <span class="pre">-</span> <span class="pre">a</span> <span class="pre">&#64;</span> <span class="pre">x||</span></code>.
If <code class="docutils literal notranslate"><span class="pre">b</span></code> has a covariance matrix, another option is to weight the
norm with the inverse covariance matrix: i.e., minimize
<code class="docutils literal notranslate"><span class="pre">||</span> <span class="pre">isig</span> <span class="pre">&#64;</span> <span class="pre">b</span> <span class="pre">-</span> <span class="pre">isig</span> <span class="pre">&#64;</span> <span class="pre">a</span> <span class="pre">&#64;</span> <span class="pre">x||</span></code> where <code class="docutils literal notranslate"><span class="pre">isig</span></code> is the square root of the
inverse of <code class="docutils literal notranslate"><span class="pre">b</span></code>’s covariance matrix. Set parameter <code class="docutils literal notranslate"><span class="pre">weighted=True</span></code> to
obtain the weighted-least-squares solution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – Matrix/array of shape <code class="docutils literal notranslate"><span class="pre">(M,N)</span></code> containing numbers and/or <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code></a>s.</p></li>
<li><p><strong>b</strong> – Vector/array of shape <code class="docutils literal notranslate"><span class="pre">(M,)</span></code> containing numbers and/or <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code></a>s.</p></li>
<li><p><strong>rcond</strong> (<em>float</em>) – Cutoff for singular values of <code class="docutils literal notranslate"><span class="pre">a</span></code>. Singular values
smaller than <code class="docutils literal notranslate"><span class="pre">rcond</span></code> times the maximum eigenvalue are ignored.
Default (<code class="docutils literal notranslate"><span class="pre">rcond=None</span></code>) is <code class="docutils literal notranslate"><span class="pre">max(M,N)</span></code> times machine precision.</p></li>
<li><p><strong>weighted</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, use weighted least squares; otherwise
use unweighted least squares.</p></li>
<li><p><strong>extrainfo</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">False</span></code> (default) only <code class="docutils literal notranslate"><span class="pre">x</span></code> is returned;
otherwise <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">residual,</span> <span class="pre">rank,</span> <span class="pre">s)</span></code> is returned.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Array <code class="docutils literal notranslate"><span class="pre">x</span></code> of shape <code class="docutils literal notranslate"><span class="pre">(N,)</span></code> that minimizes <code class="docutils literal notranslate"><span class="pre">||</span> <span class="pre">b</span> <span class="pre">-</span> <span class="pre">a</span> <span class="pre">&#64;</span> <span class="pre">x||</span></code>
if <code class="docutils literal notranslate"><span class="pre">extrainfo==False</span></code> (default); otherwise returns a tuple
<code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">residual,</span> <span class="pre">rank,</span> <span class="pre">s)</span></code> where <code class="docutils literal notranslate"><span class="pre">residual</span></code> is the sum
of the squares of <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">-</span> <span class="pre">a</span> <span class="pre">&#64;</span> <span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">rank</span></code> is the rank of matrix
<code class="docutils literal notranslate"><span class="pre">a</span></code>, and <code class="docutils literal notranslate"><span class="pre">s</span></code> is an array containing the singular values.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gvar.linalg.eigvalsh">
<span class="sig-prename descclassname"><span class="pre">linalg.</span></span><span class="sig-name descname"><span class="pre">eigvalsh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigvec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.linalg.eigvalsh" title="Permalink to this definition">¶</a></dt>
<dd><p>Eigenvalues of Hermitian matrix <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – Two-dimensional, square Hermitian matrix/array of numbers
and/or <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code></a>s. Array elements must be
real-valued if <cite>gvar.GVar</cite>s are involved (i.e., symmetric
matrix).</p></li>
<li><p><strong>eigvec</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, method returns a tuple of arrays
<code class="docutils literal notranslate"><span class="pre">(val,</span> <span class="pre">vec)</span></code> where <code class="docutils literal notranslate"><span class="pre">val[i]</span></code> are the
eigenvalues of <code class="docutils literal notranslate"><span class="pre">a</span></code>, and <code class="docutils literal notranslate"><span class="pre">vec[:,</span> <span class="pre">i]</span></code> are the mean
values of the corresponding eigenvectors. Only <code class="docutils literal notranslate"><span class="pre">val</span></code> is
returned if <code class="docutils literal notranslate"><span class="pre">eigvec=False</span></code> (default).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Array <code class="docutils literal notranslate"><span class="pre">val</span></code> of eigenvalues of matrix <code class="docutils literal notranslate"><span class="pre">a</span></code> if parameter
<code class="docutils literal notranslate"><span class="pre">eigvec==False</span></code> (default); otherwise a tuple of
arrays <code class="docutils literal notranslate"><span class="pre">(val,</span> <span class="pre">vec)</span></code> where <code class="docutils literal notranslate"><span class="pre">val[i]</span></code> are the eigenvalues
(in ascending order) and <code class="docutils literal notranslate"><span class="pre">vec[:,</span> <span class="pre">i]</span></code> are the mean values
of the corresponding eigenvectors.</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If matrix is not square and two-dimensional.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gvar.linalg.eigh">
<span class="sig-prename descclassname"><span class="pre">linalg.</span></span><span class="sig-name descname"><span class="pre">eigh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigvec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.linalg.eigh" title="Permalink to this definition">¶</a></dt>
<dd><p>Eigenvalues and eigenvectors of symmetric matrix <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – Two-dimensional, square Hermitian matrix/array of numbers
and/or <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code></a>s. Array elements must be
real-valued if <cite>gvar.GVar</cite>s are involved (i.e., symmetric
matrix).</p></li>
<li><p><strong>eigvec</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>  (default), method returns a tuple
of arrays <code class="docutils literal notranslate"><span class="pre">(val,</span> <span class="pre">vec)</span></code> where <code class="docutils literal notranslate"><span class="pre">val[i]</span></code> are the
eigenvalues of <code class="docutils literal notranslate"><span class="pre">a</span></code> (in ascending order), and <code class="docutils literal notranslate"><span class="pre">vec[:,</span> <span class="pre">i]</span></code>
are the corresponding eigenvectors of <code class="docutils literal notranslate"><span class="pre">a</span></code>. Only <code class="docutils literal notranslate"><span class="pre">val</span></code> is
returned if <code class="docutils literal notranslate"><span class="pre">eigvec=False</span></code>.</p></li>
<li><p><strong>rcond</strong> (<em>float</em>) – Eigenvalues whose difference is smaller than
<code class="docutils literal notranslate"><span class="pre">rcond</span></code> times their sum are assumed to be degenerate
(and ignored) when computing variances for the eigvectors.
Default (<code class="docutils literal notranslate"><span class="pre">rcond=None</span></code>) is <code class="docutils literal notranslate"><span class="pre">N</span></code> times machine precision,
where <code class="docutils literal notranslate"><span class="pre">N</span></code> is the dimension of the array.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Tuple <code class="docutils literal notranslate"><span class="pre">(val,vec)</span></code> of eigenvalues and eigenvectors of
matrix <code class="docutils literal notranslate"><span class="pre">a</span></code> if parameter <code class="docutils literal notranslate"><span class="pre">eigvec==True</span></code> (default).
The eigenvalues <code class="docutils literal notranslate"><span class="pre">val[i]</span></code> are in ascending order and
<code class="docutils literal notranslate"><span class="pre">vec[:,</span> <span class="pre">i]</span></code> are the corresponding eigenvalues. Only
the eigenvalues <code class="docutils literal notranslate"><span class="pre">val</span></code> are returned if <code class="docutils literal notranslate"><span class="pre">eigvec=False</span></code>.</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If matrix is not square and two-dimensional.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gvar.linalg.svd">
<span class="sig-prename descclassname"><span class="pre">linalg.</span></span><span class="sig-name descname"><span class="pre">svd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute_uv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.linalg.svd" title="Permalink to this definition">¶</a></dt>
<dd><p>svd decomposition of matrix <code class="docutils literal notranslate"><span class="pre">a</span></code> containing <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code></a>s.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – Two-dimensional matrix/array of numbers
and/or <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code></a>s.</p></li>
<li><p><strong>compute_uv</strong> (<em>bool</em>) – It <code class="docutils literal notranslate"><span class="pre">True</span></code> (default), returns
tuple <code class="docutils literal notranslate"><span class="pre">(u,s,vT)</span></code> where matrix <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">u</span> <span class="pre">&#64;</span> <span class="pre">np.diag(s)</span> <span class="pre">&#64;</span> <span class="pre">vT</span></code>
where matrices <code class="docutils literal notranslate"><span class="pre">u</span></code> and <code class="docutils literal notranslate"><span class="pre">vT</span></code> satisfy <code class="docutils literal notranslate"><span class="pre">u.T</span> <span class="pre">&#64;</span> <span class="pre">u</span> <span class="pre">=</span> <span class="pre">1</span></code>
and <code class="docutils literal notranslate"><span class="pre">vT</span> <span class="pre">&#64;</span> <span class="pre">vT.T</span> <span class="pre">=</span> <span class="pre">1</span></code>, and <code class="docutils literal notranslate"><span class="pre">s</span></code> is the list of singular
values. Only <code class="docutils literal notranslate"><span class="pre">s</span></code> is returned if <code class="docutils literal notranslate"><span class="pre">compute_uv=False</span></code>.</p></li>
<li><p><strong>rcond</strong> (<em>float</em>) – Singular values whose difference is smaller than
<code class="docutils literal notranslate"><span class="pre">rcond</span></code> times their sum are assumed to be degenerate for
calculating variances for <code class="docutils literal notranslate"><span class="pre">u</span></code> and <code class="docutils literal notranslate"><span class="pre">vT</span></code>.
Default (<code class="docutils literal notranslate"><span class="pre">rcond=None</span></code>) is <code class="docutils literal notranslate"><span class="pre">max(M,N)</span></code> times machine precision.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Tuple <code class="docutils literal notranslate"><span class="pre">(u,s,vT)</span></code> where matrix <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">u</span> <span class="pre">&#64;</span> <span class="pre">np.diag(s)</span> <span class="pre">&#64;</span> <span class="pre">vT</span></code>
where matrices <code class="docutils literal notranslate"><span class="pre">u</span></code> and <code class="docutils literal notranslate"><span class="pre">vT</span></code> satisfy <code class="docutils literal notranslate"><span class="pre">u.T</span> <span class="pre">&#64;</span> <span class="pre">u</span> <span class="pre">=</span> <span class="pre">1</span></code>
and <code class="docutils literal notranslate"><span class="pre">vT</span> <span class="pre">&#64;</span> <span class="pre">vT.T</span> <span class="pre">=</span> <span class="pre">1</span></code>, and <code class="docutils literal notranslate"><span class="pre">s</span></code> is the list of singular
values. If <code class="docutils literal notranslate"><span class="pre">a.shape=(N,M)</span></code>, then <code class="docutils literal notranslate"><span class="pre">u.shape=(N,K)</span></code>
and <code class="docutils literal notranslate"><span class="pre">vT.shape=(K,M)</span></code> where <code class="docutils literal notranslate"><span class="pre">K</span></code> is the number of
nonzero singular values (<code class="docutils literal notranslate"><span class="pre">len(s)==K</span></code>).
If <code class="docutils literal notranslate"><span class="pre">compute_uv==False</span></code> only <code class="docutils literal notranslate"><span class="pre">s</span></code> is returned.</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If matrix is not two-dimensional.</p>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-gvar.ode"></span></section>
<section id="ordinary-differential-equations">
<h2>Ordinary Differential Equations<a class="headerlink" href="#ordinary-differential-equations" title="Permalink to this heading">¶</a></h2>
<p>Module <a class="reference internal" href="#module-gvar.ode" title="gvar.ode: Ordinary differential equations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar.ode</span></code></a> implements two classes for integrating systems
of first-order differential equations using an adaptive Runge-Kutta
algorithm. One integrates scalar- or array-valued equations, while the
other integrates dictionary-valued equations:</p>
<dl class="py class">
<dt class="sig sig-object py" id="gvar.ode.Integrator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">gvar.ode.</span></span><span class="sig-name descname"><span class="pre">Integrator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deriv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hmin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxstep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">analyzer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.ode.Integrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrate <code class="docutils literal notranslate"><span class="pre">dy/dx</span> <span class="pre">=</span> <span class="pre">deriv(x,y)</span></code>.</p>
<p>An <a class="reference internal" href="#gvar.ode.Integrator" title="gvar.ode.Integrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integrator</span></code></a> object <code class="docutils literal notranslate"><span class="pre">odeint</span></code> integrates
<code class="docutils literal notranslate"><span class="pre">dy/dx</span> <span class="pre">=</span> <span class="pre">f(x,y)</span></code> to obtain <code class="docutils literal notranslate"><span class="pre">y(x1)</span></code> from <code class="docutils literal notranslate"><span class="pre">y0</span> <span class="pre">=</span> <span class="pre">y(x0)</span></code>.
<code class="docutils literal notranslate"><span class="pre">y</span></code> and <code class="docutils literal notranslate"><span class="pre">f(x,y)</span></code> can be scalars or <code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code> arrays.
Typical usage is illustrated by the following code
for integrating <code class="docutils literal notranslate"><span class="pre">dy/dx</span> <span class="pre">=</span> <span class="pre">y</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">gvar.ode</span> <span class="kn">import</span> <span class="n">Integrator</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">y</span>

<span class="n">odeint</span> <span class="o">=</span> <span class="n">Integrator</span><span class="p">(</span><span class="n">deriv</span><span class="o">=</span><span class="n">f</span><span class="p">,</span>  <span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">)</span>
<span class="n">y0</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="n">y1</span> <span class="o">=</span> <span class="n">odeint</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.</span><span class="p">))</span>
<span class="n">y2</span> <span class="o">=</span> <span class="n">odeint</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">))</span>
<span class="o">...</span>
</pre></div>
</div>
<p>Here the first call to <code class="docutils literal notranslate"><span class="pre">odeint</span></code> integrates the differential equation
from <code class="docutils literal notranslate"><span class="pre">x=0</span></code> to <code class="docutils literal notranslate"><span class="pre">x=1</span></code> starting with <code class="docutils literal notranslate"><span class="pre">y=y0</span></code> at <code class="docutils literal notranslate"><span class="pre">x=0</span></code>; the result
is <code class="docutils literal notranslate"><span class="pre">y1=exp(1)</span></code>, of course. Similarly the second call to <code class="docutils literal notranslate"><span class="pre">odeint</span></code>
continues the integration from <code class="docutils literal notranslate"><span class="pre">x=1</span></code> to <code class="docutils literal notranslate"><span class="pre">x=2</span></code>, giving <code class="docutils literal notranslate"><span class="pre">y2=exp(2)</span></code>.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">interval</span></code> is a list with more than two entries,
then <code class="docutils literal notranslate"><span class="pre">odeint(y0,</span> <span class="pre">interval=[x0,</span> <span class="pre">x1,</span> <span class="pre">x2</span> <span class="pre">...])</span></code> in the example above
returns an array of solutions for points <code class="docutils literal notranslate"><span class="pre">x1,</span> <span class="pre">x2</span> <span class="pre">...</span></code>. So the example
above could have been written equivalently as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>

<span class="n">odeint</span> <span class="o">=</span> <span class="n">Integrator</span><span class="p">(</span><span class="n">deriv</span><span class="o">=</span><span class="n">f</span><span class="p">,</span>  <span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">)</span>
<span class="n">y0</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="n">y1</span><span class="p">,</span> <span class="n">y2</span> <span class="o">...</span> <span class="o">=</span> <span class="n">odeint</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span> <span class="o">...</span><span class="p">])</span>
</pre></div>
</div>
<p>An alternative interface creates a new function which is the
solution of the differential equation for specific initial conditions.
The code above could be rewritten:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x0</span> <span class="o">=</span> <span class="mf">0.</span>         <span class="c1"># initial conditions</span>
<span class="n">y0</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">Integrator</span><span class="p">(</span><span class="n">deriv</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">)</span><span class="o">.</span><span class="n">solution</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">)</span>
<span class="n">y1</span> <span class="o">=</span> <span class="n">y</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">y2</span> <span class="o">=</span> <span class="n">y</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
<p>Here method <code class="xref py py-meth docutils literal notranslate"><span class="pre">Integrator.solution()</span></code> returns a function <code class="docutils literal notranslate"><span class="pre">y(x)</span></code>
where: a) <code class="docutils literal notranslate"><span class="pre">y(x0)</span> <span class="pre">=</span> <span class="pre">y0</span></code>; and b) <code class="docutils literal notranslate"><span class="pre">y(x)</span></code> uses the integator to
integrate the differential equation to point <code class="docutils literal notranslate"><span class="pre">x</span></code> starting
from  the last point at which <code class="docutils literal notranslate"><span class="pre">y</span></code> was evaluated
(or from <code class="docutils literal notranslate"><span class="pre">x0</span></code> for the first call to <code class="docutils literal notranslate"><span class="pre">y(x)</span></code>). The function can
also be called with an array of <code class="docutils literal notranslate"><span class="pre">x</span></code> values, in which case an
array containing the corresponding <code class="docutils literal notranslate"><span class="pre">y</span></code> values is returned.</p>
<p>The integrator uses an adaptive Runge-Kutta algorithm that adjusts
the integrator’s step size to obtain relative accuracy <code class="docutils literal notranslate"><span class="pre">tol</span></code>
in the solution. An initial step size can be set in the
<a class="reference internal" href="#gvar.ode.Integrator" title="gvar.ode.Integrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integrator</span></code></a> by specifying parameter <code class="docutils literal notranslate"><span class="pre">h</span></code>. A minimum
step size <code class="docutils literal notranslate"><span class="pre">hmin</span></code> can also be specified; the <a class="reference internal" href="#gvar.ode.Integrator" title="gvar.ode.Integrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integrator</span></code></a>
raises an exception if the step size becomes smaller than <code class="docutils literal notranslate"><span class="pre">hmin</span></code>.
The <a class="reference internal" href="#gvar.ode.Integrator" title="gvar.ode.Integrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integrator</span></code></a> keeps track of the number of good steps,
where <code class="docutils literal notranslate"><span class="pre">h</span></code> is increased, and the number of bad steps, where <code class="docutils literal notranslate"><span class="pre">h</span></code>
is decreased and the step is repeated:
<code class="docutils literal notranslate"><span class="pre">odeint.ngood</span></code> and <code class="docutils literal notranslate"><span class="pre">odeint.nbad</span></code>, respectively.</p>
<p>A custom criterion for step-size changes can be implemented by
specifying a function for parameter delta. This is a function
<code class="docutils literal notranslate"><span class="pre">delta(yerr,</span> <span class="pre">y,</span> <span class="pre">delta_y)</span></code> — of the estimated error <code class="docutils literal notranslate"><span class="pre">yerr</span></code>
after a given step, the proposed value for <code class="docutils literal notranslate"><span class="pre">y</span></code>, and the
proposed change <code class="docutils literal notranslate"><span class="pre">delta_y</span></code> in <code class="docutils literal notranslate"><span class="pre">y</span></code> — that returns a number
to compare with tolerance <code class="docutils literal notranslate"><span class="pre">tol</span></code>. The step size is
decreased and the step repeated if <code class="docutils literal notranslate"><span class="pre">delta(yerr,</span> <span class="pre">y,</span> <span class="pre">delta_y)</span> <span class="pre">&gt;</span> <span class="pre">tol</span></code>;
otherwise the step is accepted and the step size increased.
The default definition of <code class="docutils literal notranslate"><span class="pre">delta</span></code> is equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">gvar</span> <span class="k">as</span> <span class="nn">gv</span>

<span class="k">def</span> <span class="nf">delta</span><span class="p">(</span><span class="n">yerr</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">delta_y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">yerr</span><span class="p">)</span> <span class="o">/</span>
        <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">delta_y</span><span class="p">)</span> <span class="o">+</span> <span class="n">gv</span><span class="o">.</span><span class="n">ode</span><span class="o">.</span><span class="n">TINY</span><span class="p">)</span>
        <span class="p">)</span>
</pre></div>
</div>
<p>An analyzer <code class="docutils literal notranslate"><span class="pre">analyzer(x,y)</span></code> can be specified using parameter
<code class="docutils literal notranslate"><span class="pre">analyzer</span></code>. This function is called after every full step of
the integration, with the current values of <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>.
Objects of type <a class="reference internal" href="#gvar.ode.Solution" title="gvar.ode.Solution"><code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.ode.Solution</span></code></a> are examples of
(simple) analyzers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>deriv</strong> – Function of <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> that returns <code class="docutils literal notranslate"><span class="pre">dy/dx</span></code>.
The return value should have the same shape as <code class="docutils literal notranslate"><span class="pre">y</span></code> if arrays
are used.</p></li>
<li><p><strong>tol</strong> (<em>float</em>) – Relative accuracy in <code class="docutils literal notranslate"><span class="pre">y</span></code> relative to
<code class="docutils literal notranslate"><span class="pre">|y|</span> <span class="pre">+</span> <span class="pre">h|dy/dx|</span></code> for each step in the integration.
Any integration step that achieves less precision is
repeated with a smaller step size. The step size
is increased if precision is higher than needed.
Default is 1e-5.</p></li>
<li><p><strong>h</strong> (<em>float</em><em> or </em><em>None</em>) – Absolute value of initial step size.
The default value equals the entire width of the
integration interval.</p></li>
<li><p><strong>hmin</strong> (<em>float</em><em> or </em><em>None</em>) – Smallest step size allowed. A warning
is raised if a smaller step size is requested, and
the step size is not decreased. This prevents infinite loops
at singular points, but the solution may not be reliable when
a warning has been issued. The default value is <code class="docutils literal notranslate"><span class="pre">None</span></code>
(which does <em>not</em> prevent infinite loops).</p></li>
<li><p><strong>hmax</strong> (<em>float</em><em> or </em><em>None</em>) – Largest step allowed. Ignored if
set to <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
<li><p><strong>maxstep</strong> (<em>int</em><em> or </em><em>None</em>) – Maximum number of integration steps
allowed, after which a <code class="docutils literal notranslate"><span class="pre">RuntimeError</span></code> exception is raised.
Ignored if set to <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
<li><p><strong>delta</strong> – Function <code class="docutils literal notranslate"><span class="pre">delta(yerr,</span> <span class="pre">y,</span> <span class="pre">delta_y)</span></code> that returns
a number to be compared  with <code class="docutils literal notranslate"><span class="pre">tol</span></code> at each integration step:
if it is larger than <code class="docutils literal notranslate"><span class="pre">tol</span></code>, the step is repeated with a smaller
step size; if it is smaller the step is accepted and a larger
step size used for the subsequent step. Here <code class="docutils literal notranslate"><span class="pre">yerr</span></code> is an
estimate of the error in <code class="docutils literal notranslate"><span class="pre">y</span></code> on the last step; <code class="docutils literal notranslate"><span class="pre">y</span></code> is the
proposed value; and <code class="docutils literal notranslate"><span class="pre">delta_y</span></code> is the change in <code class="docutils literal notranslate"><span class="pre">y</span></code> over
the last step.</p></li>
<li><p><strong>analyzer</strong> – Function of <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> that is called after each
step of the integration. This can be used to analyze intermediate
results.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="gvar.ode.DictIntegrator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">gvar.ode.</span></span><span class="sig-name descname"><span class="pre">DictIntegrator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deriv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hmin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxstep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">analyzer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.ode.DictIntegrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrate <code class="docutils literal notranslate"><span class="pre">dy/dx</span> <span class="pre">=</span> <span class="pre">deriv(x,y)</span></code> where <code class="docutils literal notranslate"><span class="pre">y</span></code> is a dictionary.</p>
<p>An <a class="reference internal" href="#gvar.ode.DictIntegrator" title="gvar.ode.DictIntegrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">DictIntegrator</span></code></a> object <code class="docutils literal notranslate"><span class="pre">odeint</span></code>
integrates <code class="docutils literal notranslate"><span class="pre">dy/dx</span> <span class="pre">=</span> <span class="pre">f(x,y)</span></code> to obtain <code class="docutils literal notranslate"><span class="pre">y(x1)</span></code> from
<code class="docutils literal notranslate"><span class="pre">y0</span> <span class="pre">=</span> <span class="pre">y(x0)</span></code>. <code class="docutils literal notranslate"><span class="pre">y</span></code> and <code class="docutils literal notranslate"><span class="pre">f(x,y)</span></code> are
dictionary types having the same keys, and containing scalars
and/or <code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code> arrays as values. Typical usage is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">gvar.ode</span> <span class="kn">import</span> <span class="n">DictIntegrator</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="o">...</span>

<span class="n">odeint</span> <span class="o">=</span> <span class="n">DictIntegrator</span><span class="p">(</span><span class="n">deriv</span><span class="o">=</span><span class="n">f</span><span class="p">,</span>  <span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">)</span>
<span class="n">y1</span> <span class="o">=</span> <span class="n">odeint</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">))</span>
<span class="n">y2</span> <span class="o">=</span> <span class="n">odeint</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">))</span>
<span class="o">...</span>
</pre></div>
</div>
<p>The first call to <code class="docutils literal notranslate"><span class="pre">odeint</span></code> integrates from <code class="docutils literal notranslate"><span class="pre">x=x0</span></code> to <code class="docutils literal notranslate"><span class="pre">x=x1</span></code>,
returning <code class="docutils literal notranslate"><span class="pre">y1=y(x1)</span></code>. The second call continues the integration
to <code class="docutils literal notranslate"><span class="pre">x=x2</span></code>, returning <code class="docutils literal notranslate"><span class="pre">y2=y(x2)</span></code>. Multiple integration points
can be specified in <code class="docutils literal notranslate"><span class="pre">interval</span></code>, in which case a list of the
corresponding <code class="docutils literal notranslate"><span class="pre">y</span></code> values is returned: for example,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">odeint</span> <span class="o">=</span> <span class="n">DictIntegrator</span><span class="p">(</span><span class="n">deriv</span><span class="o">=</span><span class="n">f</span><span class="p">,</span>  <span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">)</span>
<span class="n">y1</span><span class="p">,</span> <span class="n">y2</span> <span class="o">...</span> <span class="o">=</span> <span class="n">odeint</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="p">[</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">...</span><span class="p">])</span>
</pre></div>
</div>
<p>The integrator uses an adaptive Runge-Kutta algorithm that adjusts
the integrator’s step size to obtain relative accuracy <code class="docutils literal notranslate"><span class="pre">tol</span></code>
in the solution. An initial step size can be set in the
<a class="reference internal" href="#gvar.ode.DictIntegrator" title="gvar.ode.DictIntegrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">DictIntegrator</span></code></a> by specifying parameter <code class="docutils literal notranslate"><span class="pre">h</span></code>.
A minimum ste psize <code class="docutils literal notranslate"><span class="pre">hmin</span></code> can also be specified; the
<a class="reference internal" href="#gvar.ode.Integrator" title="gvar.ode.Integrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integrator</span></code></a> raises an exception if the step size becomes
smaller than <code class="docutils literal notranslate"><span class="pre">hmin</span></code>. The <a class="reference internal" href="#gvar.ode.DictIntegrator" title="gvar.ode.DictIntegrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">DictIntegrator</span></code></a> keeps track of the
number of good steps, where <code class="docutils literal notranslate"><span class="pre">h</span></code> is increased, and the number of
bad steps, where <code class="docutils literal notranslate"><span class="pre">h</span></code> is decreases and the step is repeated:
<code class="docutils literal notranslate"><span class="pre">odeint.ngood</span></code> and <code class="docutils literal notranslate"><span class="pre">odeint.nbad</span></code>, respectively.</p>
<p>An analyzer <code class="docutils literal notranslate"><span class="pre">analyzer(x,y)</span></code> can be specified using parameter
<code class="docutils literal notranslate"><span class="pre">analyzer</span></code>. This function is called after every full step of
the integration with the current values of <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>.
Objects of type <a class="reference internal" href="#gvar.ode.Solution" title="gvar.ode.Solution"><code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.ode.Solution</span></code></a> are examples of
(simple) analyzers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>deriv</strong> – Function of <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> that returns <code class="docutils literal notranslate"><span class="pre">dy/dx</span></code>.
The return value should be a dictionary with the same
keys as <code class="docutils literal notranslate"><span class="pre">y</span></code>, and values that have the same
shape as the corresponding values in <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p></li>
<li><p><strong>tol</strong> (<em>float</em>) – Relative accuracy in <code class="docutils literal notranslate"><span class="pre">y</span></code> relative to
<code class="docutils literal notranslate"><span class="pre">|y|</span> <span class="pre">+</span> <span class="pre">h|dy/dx|</span></code> for each step in the integration.
Any integration step that achieves less precision is
repeated with a smaller step size. The step size
is increased if precision is higher than needed.
Default is 1e-5.</p></li>
<li><p><strong>h</strong> (<em>float</em><em> or </em><em>None</em>) – Absolute value of initial step size.
The default value equals the entire width of the
integration interval.</p></li>
<li><p><strong>hmin</strong> (<em>float</em><em> or </em><em>None</em>) – Smallest step size allowed. A warning
is raised if a smaller step size is requested, and
the step size is not decreased. This prevents infinite loops
at singular points, but the solution may not be reliable when
a warning has been issued. The default value is <code class="docutils literal notranslate"><span class="pre">None</span></code>
(which does <em>not</em> prevent infinite loops).</p></li>
<li><p><strong>hmax</strong> (<em>float</em><em> or </em><em>None</em>) – Largest step allowed. Ignored if
set to <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
<li><p><strong>maxstep</strong> (<em>int</em><em> or </em><em>None</em>) – Maximum number of integration steps
allowed, after which a <code class="docutils literal notranslate"><span class="pre">RuntimeError</span></code> exception is raised.
Ignored if set to <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
<li><p><strong>delta</strong> – Function <code class="docutils literal notranslate"><span class="pre">delta(yerr,</span> <span class="pre">y,</span> <span class="pre">delta_y)</span></code> that returns
a number to be compared  with <code class="docutils literal notranslate"><span class="pre">tol</span></code> at each integration step:
if it is larger than <code class="docutils literal notranslate"><span class="pre">tol</span></code>, the step is repeated with a smaller
step size; if it is smaller the step is accepted and a larger
step size used for the subsequent step. Here <code class="docutils literal notranslate"><span class="pre">yerr</span></code> is an
estimate of the error in <code class="docutils literal notranslate"><span class="pre">y</span></code> on the last step; <code class="docutils literal notranslate"><span class="pre">y</span></code> is the
proposed value; and <code class="docutils literal notranslate"><span class="pre">delta_y</span></code> is the change in <code class="docutils literal notranslate"><span class="pre">y</span></code> over
the last step.</p></li>
<li><p><strong>analyzer</strong> – Function of <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> that is called after each
step of the integration. This can be used to analyze intermediate
results.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<p>A simple analyzer class is:</p>
<dl class="py class">
<dt class="sig sig-object py" id="gvar.ode.Solution">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">gvar.ode.</span></span><span class="sig-name descname"><span class="pre">Solution</span></span><a class="headerlink" href="#gvar.ode.Solution" title="Permalink to this definition">¶</a></dt>
<dd><p>ODE analyzer for storing intermediate values.</p>
<p>Usage: eg, given</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">odeint</span> <span class="o">=</span> <span class="n">Integrator</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">soln</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="n">y0</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">odeint</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">analyzer</span><span class="o">=</span><span class="n">soln</span><span class="p">)</span>
</pre></div>
</div>
<p>then the <code class="docutils literal notranslate"><span class="pre">soln.x[i]</span></code> are the points at which the integrator
evaluated the solution, and <code class="docutils literal notranslate"><span class="pre">soln.y[i]</span></code> is the solution
of the differential equation at that point.</p>
</dd></dl>

</section>
<section id="one-dimensional-integration">
<span id="integral"></span><h2>One-Dimensional Integration<a class="headerlink" href="#one-dimensional-integration" title="Permalink to this heading">¶</a></h2>
<p>Module <a class="reference internal" href="#module-gvar.ode" title="gvar.ode: Ordinary differential equations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar.ode</span></code></a> also provides a method for evaluating
one-dimensional integrals (using its adaptive Runge-Kutta algorithm):</p>
<dl class="py function">
<dt class="sig sig-object py" id="gvar.ode.integral">
<span class="sig-prename descclassname"><span class="pre">gvar.ode.</span></span><span class="sig-name descname"><span class="pre">integral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fcn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interval</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fcnshape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hmin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.ode.integral" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute integral of <code class="docutils literal notranslate"><span class="pre">fcn(x)</span></code> on interval.</p>
<p>Given a function <code class="docutils literal notranslate"><span class="pre">fcn(x)</span></code> the call</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">integral</span><span class="p">(</span><span class="n">fcn</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">))</span>
</pre></div>
</div>
<p>calculates the integral of <code class="docutils literal notranslate"><span class="pre">fcn(x)</span></code> from <code class="docutils literal notranslate"><span class="pre">x0</span></code> to <code class="docutils literal notranslate"><span class="pre">x1</span></code>.
For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">fcn</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>   <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">integral</span><span class="p">(</span><span class="n">fcn</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">0.500000002834</span>
</pre></div>
</div>
<p>Function <code class="docutils literal notranslate"><span class="pre">fcn(x)</span></code> can return a scalar or an array (any shape):
for example,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">fcn</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>   <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="p">])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">integral</span><span class="p">(</span><span class="n">fcn</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">[1. 0.5 0.25]</span>
</pre></div>
</div>
<p>The function can also return dictionaries whose values are
scalars or arrays: for example,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">fcn</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>   <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">x3</span><span class="o">=</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">integral</span><span class="p">(</span><span class="n">fcn</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">{&#39;x&#39;: 0.5,&#39;x3&#39;: 0.25}</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fcn</strong> – Function of scalar variable <code class="docutils literal notranslate"><span class="pre">x</span></code> that returns the integrand.
The return value should be either a scalar or an array, or a
dictionary whose values are scalars and/or arrays.</p></li>
<li><p><strong>interval</strong> – Contains the interval <code class="docutils literal notranslate"><span class="pre">(x0,x1)</span></code> over which the integral
is computed.</p></li>
<li><p><strong>fcnshape</strong> – Contains the shape of the array returned by <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> or
<code class="docutils literal notranslate"><span class="pre">()</span></code> if the function returns a scalar. Setting <code class="docutils literal notranslate"><span class="pre">fshape=None</span></code>
(the default) results in an extra function evaluation to determine
the shape.</p></li>
<li><p><strong>tol</strong> – Relative accuracy of result.</p></li>
<li><p><strong>hmin</strong> – Smallest step size allowed in adaptive integral. A warning is
raised if a smaller step size is requested, and the step size is not
decreased. This prevents infinite loops at singular points, but
the integral may not be accurate when a warning has been issued. The
default value is <code class="docutils literal notranslate"><span class="pre">None</span></code> (which does <em>not</em> prevent infinite loops).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="pade-approximants">
<h2>Pade Approximants<a class="headerlink" href="#pade-approximants" title="Permalink to this heading">¶</a></h2>
<p>Module <code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar.pade</span></code> provides a class to represent Pade
approximants of functions:</p>
<dl class="py class">
<dt class="sig sig-object py" id="gvar.pade.Pade">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">gvar.pade.</span></span><span class="sig-name descname"><span class="pre">Pade</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gavg'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.pade.Pade" title="Permalink to this definition">¶</a></dt>
<dd><p>Pade approximant to <code class="docutils literal notranslate"><span class="pre">sum_i</span> <span class="pre">f[i]</span> <span class="pre">x**i</span></code> for <code class="docutils literal notranslate"><span class="pre">GVar</span></code>s.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">order=(m,n)</span></code> Pade approximant to a series given by
<code class="docutils literal notranslate"><span class="pre">sum_i</span> <span class="pre">f[i]</span> <span class="pre">*</span> <span class="pre">x**i</span></code> is the ratio of  polynomials of order <code class="docutils literal notranslate"><span class="pre">m</span></code>
(numerator) and <code class="docutils literal notranslate"><span class="pre">n</span></code> (denominator) whose  Taylor expansion agrees
with that of the original series up to order <code class="docutils literal notranslate"><span class="pre">m+n</span></code>.</p>
<p>A <a class="reference internal" href="#gvar.pade.Pade" title="gvar.pade.Pade"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pade</span></code></a> object <code class="docutils literal notranslate"><span class="pre">pade</span></code> creates <a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.powerseries.PowerSeries</span></code></a>
objects for the numerator (<code class="docutils literal notranslate"><span class="pre">pade.num</span></code>) and the denominator (<code class="docutils literal notranslate"><span class="pre">pade.den</span></code>)
of the Pade approximant corresponding to the input series <code class="docutils literal notranslate"><span class="pre">f[i]</span></code>. The
approximant can be evaluated for arbitrary <code class="docutils literal notranslate"><span class="pre">x</span></code> using <code class="docutils literal notranslate"><span class="pre">pade(x)</span></code>. The
coefficients used in the numerator and denominator are given by <code class="docutils literal notranslate"><span class="pre">pade.num.c</span></code>
and <code class="docutils literal notranslate"><span class="pre">pade.den.c</span></code>, respectively.</p>
<p>Elements in the series <code class="docutils literal notranslate"><span class="pre">f[i]</span></code> may be numbers or <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code></a>s.
When the latter appear, the code uses an SVD algorithm (see <a class="reference internal" href="#gvar.pade.pade_svd" title="gvar.pade.pade_svd"><code class="xref py py-func docutils literal notranslate"><span class="pre">pade_svd()</span></code></a>)
to deal with the imprecision in the input data. It automatically reduces
the order of the approximant if the extraction of Pade coefficients
is too unstable given the noise in the input data. The actual order used
in the approximant is given by <code class="docutils literal notranslate"><span class="pre">pade.order</span></code>.</p>
<p class="rubric">Examples</p>
<p>Typical usage is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gvar</span> <span class="k">as</span> <span class="nn">gv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">([</span><span class="s1">&#39;1(0)&#39;</span><span class="p">,</span> <span class="s1">&#39;1.0(1)&#39;</span><span class="p">,</span> <span class="s1">&#39;0.500(10)&#39;</span><span class="p">,</span> <span class="s1">&#39;0.1667(100)&#39;</span><span class="p">,</span><span class="s1">&#39;.04167(100)&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pade</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">pade</span><span class="o">.</span><span class="n">Pade</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">pade</span><span class="o">.</span><span class="n">num</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">pade</span><span class="o">.</span><span class="n">den</span><span class="o">.</span><span class="n">c</span><span class="p">)</span>               <span class="c1"># num and den coefficients</span>
<span class="go">[1(0) 0.50(14) 0.08(11)] [1(0) -0.50(14) 0.083(55)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">pade</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>                              <span class="c1"># evaluate pade at x=1</span>
<span class="go">2.714(99)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">pade</span><span class="o">.</span><span class="n">num</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">pade</span><span class="o">.</span><span class="n">den</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">pade</span><span class="o">.</span><span class="n">order</span><span class="p">)</span> <span class="c1"># evaluate num and den at x=1</span>
<span class="go">1.58(21) 0.583(82) (2, 2)</span>
</pre></div>
</div>
<p>When errors are larger (see <code class="docutils literal notranslate"><span class="pre">c[0]</span></code>), the order may be automatically
reduced (here to <code class="docutils literal notranslate"><span class="pre">(1,2)</span></code>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">([</span><span class="s1">&#39;1.0(1)&#39;</span><span class="p">,</span> <span class="s1">&#39;1.0(1)&#39;</span><span class="p">,</span> <span class="s1">&#39;0.500(10)&#39;</span><span class="p">,</span> <span class="s1">&#39;0.1667(100)&#39;</span><span class="p">,</span><span class="s1">&#39;.04167(100)&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pade</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">pade</span><span class="o">.</span><span class="n">Pade</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">pade</span><span class="o">.</span><span class="n">num</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">pade</span><span class="o">.</span><span class="n">den</span><span class="o">.</span><span class="n">c</span><span class="p">)</span>               <span class="c1"># num and den coefficients</span>
<span class="go">[1.00(10) 0.33(29)] [1(0) -0.67(17) 0.17(11)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">pade</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>                              <span class="c1"># evaluate pade at x=1</span>
<span class="go">2.67(20)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">pade</span><span class="o">.</span><span class="n">num</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">pade</span><span class="o">.</span><span class="n">den</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">pade</span><span class="o">.</span><span class="n">order</span><span class="p">)</span> <span class="c1"># evaluate num and den at x=1</span>
<span class="go">1.33(27) 0.500(69) (1, 2)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> – Array <code class="docutils literal notranslate"><span class="pre">f[i]</span></code> of power series coefficients for <code class="docutils literal notranslate"><span class="pre">i=0...n+m</span></code>.</p></li>
<li><p><strong>order</strong> (<em>tuple</em>) – <code class="docutils literal notranslate"><span class="pre">order=(m,n)</span></code> specifies that the numerator and
denominator of the Pade approximant have maximum order
<code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code>, respectively.</p></li>
<li><p><strong>rtol</strong> (<em>float</em><em> or </em><em>str</em>) – Relative uncertainty in the coefficients, for
use by the SVD algorithm. If <code class="docutils literal notranslate"><span class="pre">rtol</span></code> is a string, it determines
how the relative tolerance is determined from the relative
uncertainties in the <code class="docutils literal notranslate"><span class="pre">f[i]</span></code>. Set <code class="docutils literal notranslate"><span class="pre">rtol</span></code> equal to:
<code class="docutils literal notranslate"><span class="pre">'gavg'</span></code> for the geometric mean (default); <code class="docutils literal notranslate"><span class="pre">'avg'</span></code> for
the average; <code class="docutils literal notranslate"><span class="pre">'min'</span></code> for the minimum; or <code class="docutils literal notranslate"><span class="pre">'max'</span></code> for
the maximum. Otherwise a number can be specified, in which case
the uncertainties in <code class="docutils literal notranslate"><span class="pre">f[i]</span></code> are ignored. The SVD analysis
is skipped if <code class="docutils literal notranslate"><span class="pre">rtol=None</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gvar.pade.pade_gvar">
<span class="sig-prename descclassname"><span class="pre">gvar.pade.</span></span><span class="sig-name descname"><span class="pre">pade_gvar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gavg'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.pade.pade_gvar" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">(m,n)</span></code> Pade approximant to <code class="docutils literal notranslate"><span class="pre">sum_i</span> <span class="pre">f[i]</span> <span class="pre">x**i</span></code> for <code class="docutils literal notranslate"><span class="pre">GVar</span></code>s.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">(m,n)</span></code> Pade approximant to a series given by
<code class="docutils literal notranslate"><span class="pre">sum_i</span> <span class="pre">f[i]</span> <span class="pre">*</span> <span class="pre">x**i</span></code> is the ratio of  polynomials of order <code class="docutils literal notranslate"><span class="pre">m</span></code>
(numerator) and <code class="docutils literal notranslate"><span class="pre">n</span></code> (denominator) whose  Taylor expansion agrees
with that of the original series up to order <code class="docutils literal notranslate"><span class="pre">m+n</span></code>.</p>
<p>This code uses an SVD algorithm (see <a class="reference internal" href="#gvar.pade.pade_svd" title="gvar.pade.pade_svd"><code class="xref py py-func docutils literal notranslate"><span class="pre">pade_svd()</span></code></a>) to deal with
imprecision in the input data. It automatically reduces
the order of the approximant if the extraction of Pade coefficients
is too unstable given noise in the input data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> – Array <code class="docutils literal notranslate"><span class="pre">f[i]</span></code> of power series coefficients for <code class="docutils literal notranslate"><span class="pre">i=0...n+m</span></code>.</p></li>
<li><p><strong>m</strong> – Maximum order of polynomial in numerator of Pade
approximant (<code class="docutils literal notranslate"><span class="pre">m&gt;=0</span></code>).</p></li>
<li><p><strong>n</strong> – Maximum order of polynomial in denominator of Pade
approximant (<code class="docutils literal notranslate"><span class="pre">m&gt;=0</span></code>).</p></li>
<li><p><strong>rtol</strong> (<em>float</em><em> or </em><em>str</em>) – If <code class="docutils literal notranslate"><span class="pre">rtol</span></code> is a string, it determines how the
relative tolerance is determined from the relative
uncertainties in the <code class="docutils literal notranslate"><span class="pre">f[i]</span></code>. Set <code class="docutils literal notranslate"><span class="pre">rtol</span></code> equal to:
<code class="docutils literal notranslate"><span class="pre">'gavg'</span></code> for the geometric mean (default); <code class="docutils literal notranslate"><span class="pre">'avg'</span></code> for
the average; <code class="docutils literal notranslate"><span class="pre">'min'</span></code> for the minimum; or <code class="docutils literal notranslate"><span class="pre">'max'</span></code> for
the maximum. Otherwise a number can be specified, in which case
the uncertainties in <code class="docutils literal notranslate"><span class="pre">f[i]</span></code> are ignored. The SVD analysis is
skipped if <code class="docutils literal notranslate"><span class="pre">rtol=None</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Tuple of power series coefficients <code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">q)</span></code> such that
<code class="docutils literal notranslate"><span class="pre">sum_i</span> <span class="pre">p[i]</span> <span class="pre">x**i</span></code> is the numerator of the approximant,
and <code class="docutils literal notranslate"><span class="pre">sum_i</span> <span class="pre">q[i]</span> <span class="pre">x**i</span></code> is the denominator. <code class="docutils literal notranslate"><span class="pre">q[0]</span></code> is
normalized to 1.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gvar.pade.pade_svd">
<span class="sig-prename descclassname"><span class="pre">gvar.pade.</span></span><span class="sig-name descname"><span class="pre">pade_svd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-14</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.pade.pade_svd" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">(m,n)</span></code> Pade approximant to <code class="docutils literal notranslate"><span class="pre">sum_i</span> <span class="pre">f[i]</span> <span class="pre">x**i</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">(m,n)</span></code> Pade approximant to a series given by
<code class="docutils literal notranslate"><span class="pre">sum_i</span> <span class="pre">f[i]</span> <span class="pre">*</span> <span class="pre">x**i</span></code> is the ratio of  polynomials of order <code class="docutils literal notranslate"><span class="pre">m</span></code>
(numerator) and <code class="docutils literal notranslate"><span class="pre">n</span></code> (denominator) whose  Taylor expansion agrees
with that of the original series up to order <code class="docutils literal notranslate"><span class="pre">m+n</span></code>.</p>
<p>This code is adapted from P. Gonnet,  S. Guttel, L. N. Trefethen, SIAM
Review Vol 55, No. 1, 101 (2013). It uses an SVD algorithm to deal with
imprecision in the input data,  here specified by the relative tolerance
<code class="docutils literal notranslate"><span class="pre">rtol</span></code> for the  input coefficients <code class="docutils literal notranslate"><span class="pre">f[i]</span></code>. It automatically reduces
the order of the approximant if the extraction of Pade coefficients
is too unstable given tolerance <code class="docutils literal notranslate"><span class="pre">rtol</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> – Array <code class="docutils literal notranslate"><span class="pre">f[i]</span></code> of power series coefficients for <code class="docutils literal notranslate"><span class="pre">i=0...n+m</span></code>.</p></li>
<li><p><strong>m</strong> – Maximum order of polynomial in numerator of Pade
approximant (<code class="docutils literal notranslate"><span class="pre">m&gt;=0</span></code>).</p></li>
<li><p><strong>n</strong> – Maximum order of polynomial in denominator of Pade
approximant (<code class="docutils literal notranslate"><span class="pre">m&gt;=0</span></code>).</p></li>
<li><p><strong>rtol</strong> – Relative accuracy of input coefficients. (Default is 1e-14.)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Tuple of power series coefficients <code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">q)</span></code> such that
<code class="docutils literal notranslate"><span class="pre">sum_i</span> <span class="pre">p[i]</span> <span class="pre">x**i</span></code> is the numerator of the approximant,
and <code class="docutils literal notranslate"><span class="pre">sum_i</span> <span class="pre">q[i]</span> <span class="pre">x**i</span></code> is the denominator. <code class="docutils literal notranslate"><span class="pre">q[0]</span></code> is
normalized to 1.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-gvar.powerseries">
<span id="power-series"></span><h2>Power Series<a class="headerlink" href="#module-gvar.powerseries" title="Permalink to this heading">¶</a></h2>
<p>Module <a class="reference internal" href="#module-gvar.powerseries" title="gvar.powerseries: Power series arithmetic and evaluation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar.powerseries</span></code></a> provides tools for manipulating power series
approximations of functions. A function’s power series is specified by the
coefficients in its Taylor expansion with respect to an independent variable,
say <code class="docutils literal notranslate"><span class="pre">x</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;(0) * x + (f&#39;&#39;(0)/2) * x**2 + (f&#39;&#39;&#39;</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="mi">6</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="o">...</span>
     <span class="o">=</span> <span class="n">f0</span> <span class="o">+</span> <span class="n">f1</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">f2</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">f3</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="o">...</span>
</pre></div>
</div>
<p>In practice a power series is different from a polynomial because power
series, while infinite order in principle, are truncated at some finite
order in numerical applications. The <code class="docutils literal notranslate"><span class="pre">order</span></code> of a power series is the
highest power of <code class="docutils literal notranslate"><span class="pre">x</span></code> that is retained in the approximation; coefficients
for still higher-order terms are assumed to be unknown (as opposed to zero).</p>
<p>Taylor’s theorem can be used to generate power series for functions of
power series:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">g</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">f0</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="s1">&#39;(f0) * (f(x)-f0) + (g&#39;&#39;(f0)/2) * (f(x)-f0)**2 + ...</span>
        <span class="o">=</span> <span class="n">g0</span> <span class="o">+</span> <span class="n">g1</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">g2</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="o">...</span>
</pre></div>
</div>
<p>This allows us to define a full calculus for power series, where arithmetic
expressions and (sufficiently differentiable) functions of power series
return new power series.</p>
<section id="using-power-series">
<h3>Using power series<a class="headerlink" href="#using-power-series" title="Permalink to this heading">¶</a></h3>
<p>Class <a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">PowerSeries</span></code></a> provides a numerical implementation of the power series
calculus. <code class="docutils literal notranslate"><span class="pre">PowerSeries([f0,f1,f2,f3...])</span></code> is a numerical representation of
a power series with coefficients <code class="docutils literal notranslate"><span class="pre">f0,</span> <span class="pre">f1,</span> <span class="pre">f2,</span> <span class="pre">f3...</span></code> (as in <code class="docutils literal notranslate"><span class="pre">f(x)</span></code>
above). Thus, for example, we can define a 4th-order power series
approximation <code class="docutils literal notranslate"><span class="pre">f</span></code> to <code class="docutils literal notranslate"><span class="pre">exp(x)=1+x+x**2/2+...</span></code> using</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gvar</span> <span class="k">as</span> <span class="nn">gv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gvar.powerseries</span> <span class="k">as</span> <span class="nn">ps</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">PowerSeries</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mf">6.</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mf">24.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>            <span class="c1"># print the coefficients</span>
<span class="go">[ 1.          1.          0.5         0.16666667  0.04166667]</span>
</pre></div>
</div>
<p>Arithmetic expressions involving instances of class <a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">PowerSeries</span></code></a> are
themselves <a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">PowerSeries</span></code></a> as in, for example,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">f</span><span class="p">)</span>              <span class="c1"># power series for exp(-x)</span>
<span class="go">[ 1.         -1.          0.5        -0.16666667  0.04166667]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">gv</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>        <span class="c1"># power series for x</span>
<span class="go">[ 0.  1.  0. -0.  0.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span> <span class="o">/</span> <span class="n">f</span><span class="p">)</span>            <span class="c1"># power series for 1</span>
<span class="go">[ 1.  0.  0.  0.  0.]</span>
</pre></div>
</div>
<p>The standard arithmetic operators (<code class="docutils literal notranslate"><span class="pre">+,-,*,/,=,**</span></code>) are supported, as are
the usual elementary functions (<code class="docutils literal notranslate"><span class="pre">exp,</span> <span class="pre">log,</span> <span class="pre">sin,</span> <span class="pre">cos,</span> <span class="pre">tan</span> <span class="pre">...</span></code>). Different
<a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">PowerSeries</span></code></a> can be combined arithmetically to create new
<a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">PowerSeries</span></code></a>; the order of the result is that of the operand with the
lowest order.</p>
<p><a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">PowerSeries</span></code></a> can be differentiated and integrated:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">deriv</span><span class="p">())</span>    <span class="c1"># derivative of exp(x)</span>
<span class="go">[ 1.          1.          0.5         0.16666667]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">integ</span><span class="p">())</span>    <span class="c1"># integral of exp(x) (from x=0)</span>
<span class="go">[ 0.          1.          0.5         0.16666667  0.04166667  0.00833333]</span>
</pre></div>
</div>
<p>Each <a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">PowerSeries</span></code></a> represents a function. The <a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">PowerSeries</span></code></a> for
a function of a function is easily obtained. For example, assume <code class="docutils literal notranslate"><span class="pre">f</span></code>
represents function <code class="docutils literal notranslate"><span class="pre">f(x)=exp(x)</span></code>, as above, and <code class="docutils literal notranslate"><span class="pre">g</span></code>
represents <code class="docutils literal notranslate"><span class="pre">g(x)=log(1+x)</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">PowerSeries</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mf">3.</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mf">4.</span><span class="p">])</span>
</pre></div>
</div>
<p>Then <code class="docutils literal notranslate"><span class="pre">f(g)</span></code> gives the <a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">PowerSeries</span></code></a> for <code class="docutils literal notranslate"><span class="pre">exp(log(1+x))</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">x</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>
<span class="go">[  1.0000e+00   1.0000e+00   0.0000e+00  -2.7755e-17 -7.6327e-17]</span>
</pre></div>
</div>
<p>Individual coefficients from the powerseries can be accessed using
array-element notation: for example,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">1.0 1.0 0.5 0.166666666667</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>            <span class="c1"># f is now the power series for exp(x)-1</span>
<span class="go">[ 0.          1.          0.5         0.16666667  0.04166667]</span>
</pre></div>
</div>
<p>Finally, a power series can be evaluated for a particular
numerical value of x:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>             <span class="c1"># should be exp(0.01)-1 approximately</span>
<span class="go">0.0100501670833</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">gv</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>      <span class="c1"># verify that it is</span>
<span class="go">0.0100501670842</span>
</pre></div>
</div>
<p>The independent variable <code class="docutils literal notranslate"><span class="pre">x</span></code> could be of any arithmetic type (it need not
be a <code class="docutils literal notranslate"><span class="pre">float</span></code>).</p>
</section>
<section id="multivariate-power-series">
<h3>Multivariate power series<a class="headerlink" href="#multivariate-power-series" title="Permalink to this heading">¶</a></h3>
<p>The coefficients in a <a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">PowerSeries</span></code></a> object can themselves by <a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">PowerSeries</span></code></a>
objects. The is used to represent multivariate power series such as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">f00</span> <span class="o">+</span> <span class="n">f10</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">f01</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">f20</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">f11</span> <span class="o">*</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">f02</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="o">...</span>
</pre></div>
</div>
<p>One way to construct a <a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">PowerSeries</span></code></a> object <code class="docutils literal notranslate"><span class="pre">f</span></code> representing this series, through
<code class="docutils literal notranslate"><span class="pre">order=2</span></code>, is from an array <code class="docutils literal notranslate"><span class="pre">c</span></code> containing the coefficients:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="o">=</span> <span class="p">[[</span><span class="n">f00</span><span class="p">,</span> <span class="n">f01</span><span class="p">,</span> <span class="n">f02</span><span class="p">],</span> <span class="p">[</span><span class="n">f10</span><span class="p">,</span> <span class="n">f11</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">f20</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">multiseries</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Here entries for <code class="docutils literal notranslate"><span class="pre">c[1,2]</span></code>, <code class="docutils literal notranslate"><span class="pre">c[2,1]</span></code>,  and <code class="docutils literal notranslate"><span class="pre">c[2,2]</span></code> are ignored because they
correspond to <code class="docutils literal notranslate"><span class="pre">order=3</span></code> or higher.
The individual coefficients <code class="docutils literal notranslate"><span class="pre">c[i,j]</span></code> are accessed using <code class="docutils literal notranslate"><span class="pre">f[i,j]</span></code>, and the
function is evaluate at point <code class="docutils literal notranslate"><span class="pre">(x,y)</span></code> using <code class="docutils literal notranslate"><span class="pre">f(x,y)</span></code>. Similarly the first-order
partial derivative with respect to <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>, for example, is given by
<a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">PowerSeries</span></code></a> object
<code class="docutils literal notranslate"><span class="pre">f.deriv(1,1)</span></code>, while first-order integrals with respect to <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>
are given by <code class="docutils literal notranslate"><span class="pre">f.integ(1,1)</span></code>.</p>
</section>
<section id="taylor-expansions-of-python-functions">
<h3>Taylor expansions of Python functions<a class="headerlink" href="#taylor-expansions-of-python-functions" title="Permalink to this heading">¶</a></h3>
<p><a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">PowerSeries</span></code></a> can be used to compute Taylor series for more-or-less
arbitrary pure-Python functions provided the functions are
sufficiently differentiable. To compute the <code class="docutils literal notranslate"><span class="pre">N</span></code>-th order
expansion of a Python function <code class="docutils literal notranslate"><span class="pre">g(x)</span></code>, first create a <code class="docutils literal notranslate"><span class="pre">N</span></code>-th order
<a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">PowerSeries</span></code></a> variable that represents the expansion parameter: say,
<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">PowerSeries([0.,1.],order=N)</span></code>. The Taylor series for function <code class="docutils literal notranslate"><span class="pre">g</span></code>
is then given by <code class="docutils literal notranslate"><span class="pre">g_taylor</span> <span class="pre">=</span> <span class="pre">g(x)</span></code> which is a <a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">PowerSeries</span></code></a> instance.
For example, consider:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>              <span class="c1"># an example of a Python function</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="mf">0.5</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">PowerSeries</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">],</span><span class="n">order</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>    <span class="c1"># Taylor series for x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[ 0.  1.  0.  0.  0.  0.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g_taylor</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>        <span class="c1"># Taylor series for g(x) about x=0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">g_taylor</span><span class="p">)</span>
<span class="go">[ 1.         0.         0.375      0.         0.2734375  0.       ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_taylor</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># Taylor series for exp(x) about x=0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">exp_taylor</span><span class="p">)</span>
<span class="go">[ 1.          1.          0.5         0.16666667  0.04166667  0.00833333]</span>
</pre></div>
</div>
<p>This generalizes easily to multivariate expansions. For example,
one can calculate the Taylor expansion coefficients for <code class="docutils literal notranslate"><span class="pre">exp(x+y)</span></code> using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">multivar</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_taylor</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">exp_taylor</span><span class="p">)</span>
<span class="go">[[1.         1.         0.5        0.16666667], [1.  1.  0.5], [0.5 0.5], [0.16666667]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">exp_taylor</span><span class="p">(</span><span class="mf">.1</span><span class="p">,</span><span class="mf">.2</span><span class="p">),</span> <span class="n">gv</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">.1</span> <span class="o">+</span> <span class="mf">.2</span><span class="p">))</span>
<span class="go">1.3495000000000001 1.3498588075760032</span>
</pre></div>
</div>
<p>Here function <a class="reference internal" href="#gvar.powerseries.multivar" title="gvar.powerseries.multivar"><code class="xref py py-func docutils literal notranslate"><span class="pre">multivar()</span></code></a> creates <a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">PowerSeries</span></code></a> objects corresponding to the
expansion variables through a given order.</p>
</section>
<dl class="py class">
<dt class="sig sig-object py" id="gvar.powerseries.PowerSeries">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">gvar.powerseries.</span></span><span class="sig-name descname"><span class="pre">PowerSeries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.powerseries.PowerSeries" title="Permalink to this definition">¶</a></dt>
<dd><p>Power series representation of a function.</p>
<p>The power series created by <code class="docutils literal notranslate"><span class="pre">PowerSeries(c)</span></code> corresponds to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="o">...</span> <span class="o">.</span>
</pre></div>
</div>
<p>The order of the power series is normally determined by the length of
the input list <code class="docutils literal notranslate"><span class="pre">c</span></code>. This can be overridden by specifying the order of
the power series using the <code class="docutils literal notranslate"><span class="pre">order</span></code> parameter. The list of <code class="docutils literal notranslate"><span class="pre">c[i]</span></code>s
is then padded with zeros if <code class="docutils literal notranslate"><span class="pre">c</span></code> is too short, or truncated if it
is too long. Omitting <code class="docutils literal notranslate"><span class="pre">c</span></code> altogether results in a power series
all of whose coefficients are zero. Individual series
coefficients are accessed using array/list notation: for example,
the 3rd-order coefficient of <code class="docutils literal notranslate"><span class="pre">PowerSeries</span> <span class="pre">p</span></code> is <code class="docutils literal notranslate"><span class="pre">p[3]</span></code>. The
order of <code class="docutils literal notranslate"><span class="pre">p</span></code> is <code class="docutils literal notranslate"><span class="pre">p.order</span></code>. <a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">PowerSeries</span></code></a> should work
for coefficients of any data type that supports ordinary arithmetic.</p>
<p>Arithmetic expressions of <a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">PowerSeries</span></code></a> variables yield new
<a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">PowerSeries</span></code></a> results that represent the power series
expansion of the expression. Expressions can include the standard
mathematical functions (<code class="docutils literal notranslate"><span class="pre">log,</span> <span class="pre">exp,</span> <span class="pre">sqrt,</span> <span class="pre">sin,</span> <span class="pre">cos,</span> <span class="pre">tan...</span></code>).
<a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">PowerSeries</span></code></a> can also be differentiated (<code class="docutils literal notranslate"><span class="pre">p.deriv()</span></code>)
and integrated (<code class="docutils literal notranslate"><span class="pre">p.integ()</span></code>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>c</strong> (<em>array</em>) – Power series coefficients.</p></li>
<li><p><strong>order</strong> (<em>int</em><em> or </em><em>None</em>) – Highest power in power series. If <code class="docutils literal notranslate"><span class="pre">None</span></code>,
the order is inferred from the array of coefficients.
If array <code class="docutils literal notranslate"><span class="pre">c</span></code> is too small for the specified <code class="docutils literal notranslate"><span class="pre">order</span></code>,
the array is padded with zeros at the end.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="gvar.powerseries.PowerSeries.coeff">
<span class="sig-name descname"><span class="pre">coeff</span></span><a class="headerlink" href="#gvar.powerseries.PowerSeries.coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy of power series coefficients (numpy.array).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gvar.powerseries.PowerSeries.deriv">
<span class="sig-name descname"><span class="pre">deriv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.powerseries.PowerSeries.deriv" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute <em>n</em>-th derivative (or partial derivative) of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n</strong> (<em>array</em>) – Number of derivatives in each direction.  Default is <code class="docutils literal notranslate"><span class="pre">n=[1]</span></code>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">PowerSeries</span></code></a> object representing the
<em>n</em>-th derivative or partial derivative of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gvar.powerseries.PowerSeries.integ">
<span class="sig-name descname"><span class="pre">integ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.powerseries.PowerSeries.integ" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute <em>n</em>-th indefinite integral of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>If <em>x0</em> is specified, then the definite integral,
integrating from point <em>x0</em>, is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>array</em>) – Number of integrations in each direction. Default is <code class="docutils literal notranslate"><span class="pre">n=[1]</span></code>.</p></li>
<li><p><strong>x0</strong> (<em>array</em><em> or </em><em>float</em>) – Starting point for definite integral
in each direction (default is 0).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">PowerSeries</span></code></a> object representing the <em>n</em>-th integral of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gvar.powerseries.multiseries">
<span class="sig-prename descclassname"><span class="pre">gvar.powerseries.</span></span><span class="sig-name descname"><span class="pre">multiseries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.powerseries.multiseries" title="Permalink to this definition">¶</a></dt>
<dd><p>Create multivariate power series from coefficients in array <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>c</strong> (<em>array</em>) – <code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code>-like array containing the power series
coefficients. In <code class="docutils literal notranslate"><span class="pre">d</span></code> dimensions, <code class="docutils literal notranslate"><span class="pre">c[i1,i2,...,id]</span></code> is the
coefficient of <code class="docutils literal notranslate"><span class="pre">x1**i1</span> <span class="pre">*</span> <span class="pre">x2**i2</span> <span class="pre">*</span> <span class="pre">...</span> <span class="pre">*</span> <span class="pre">xd**id</span></code>.</p></li>
<li><p><strong>order</strong> (<em>int</em><em> or </em><em>None</em>) – Highest power in power series, where the power
associated with term <code class="docutils literal notranslate"><span class="pre">x1**i1</span> <span class="pre">*</span> <span class="pre">x2**i2</span> <span class="pre">*</span> <span class="pre">...</span> <span class="pre">*</span> <span class="pre">xd**id</span></code>
is the sum of the exponents: <code class="docutils literal notranslate"><span class="pre">i1</span> <span class="pre">+</span> <span class="pre">i2</span> <span class="pre">+</span> <span class="pre">...</span> <span class="pre">+</span> <span class="pre">id</span></code>. If <code class="docutils literal notranslate"><span class="pre">None</span></code>,
the order is inferred from the array of coefficients.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">PowerSeries</span></code></a> object representing the multivariate power series.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gvar.powerseries.multivar">
<span class="sig-prename descclassname"><span class="pre">gvar.powerseries.</span></span><span class="sig-name descname"><span class="pre">multivar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.powerseries.multivar" title="Permalink to this definition">¶</a></dt>
<dd><p>Create <a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">PowerSeries</span></code></a> objects representing the expansion variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – The dimensionality of the multivariate space.</p></li>
<li><p><strong>order</strong> (<em>int</em>) – Highest power in the power series,  where the power
associated with term <code class="docutils literal notranslate"><span class="pre">x1**i1</span> <span class="pre">*</span> <span class="pre">x2**i2</span> <span class="pre">*</span> <span class="pre">...</span> <span class="pre">*</span> <span class="pre">xd**id</span></code>
is the sum of the exponents: <code class="docutils literal notranslate"><span class="pre">i1</span> <span class="pre">+</span> <span class="pre">i2</span> <span class="pre">+</span> <span class="pre">...</span> <span class="pre">+</span> <span class="pre">id</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An array of <code class="docutils literal notranslate"><span class="pre">dim</span></code> <a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">PowerSeries</span></code></a> objects corresponding to
each of the expansion variables in a <code class="docutils literal notranslate"><span class="pre">dim</span></code>-dimensional multivariate
power series.</p>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-gvar.root"></span></section>
<section id="root-finding">
<h2>Root Finding<a class="headerlink" href="#root-finding" title="Permalink to this heading">¶</a></h2>
<p>Module <a class="reference internal" href="#module-gvar.root" title="gvar.root: Roots (zeros) of one-dimensional functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar.root</span></code></a> contains methods for finding the roots of
of one-dimensional functions: that is, finding <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">fcn(x)=0</span></code> for a given function <code class="docutils literal notranslate"><span class="pre">fcn</span></code>. Typical usage is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">math</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gvar</span> <span class="k">as</span> <span class="nn">gv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">interval</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>     <span class="c1"># bracket root</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>
<span class="go">(3.1384283767210035, 3.4522712143931042)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">refine</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="n">interval</span><span class="p">)</span>   <span class="c1"># refine root</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="go">3.14159265359</span>
</pre></div>
</div>
<p>This code finds the first root of <code class="docutils literal notranslate"><span class="pre">sin(x)=0</span></code> larger than 1. The first
setp is a search to find an interval containing a root. Here
<a class="reference internal" href="#gvar.root.search" title="gvar.root.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gvar.root.search()</span></code></a> examines <code class="docutils literal notranslate"><span class="pre">sin(x)</span></code> for a sequence of points
<code class="docutils literal notranslate"><span class="pre">1.</span> <span class="pre">*</span> <span class="pre">1.1</span> <span class="pre">**</span> <span class="pre">n</span></code> for <code class="docutils literal notranslate"><span class="pre">n=0,1,2...</span></code>, stopping when the function changes
sign. The last two points in the sequence then bracket a root
since <code class="docutils literal notranslate"><span class="pre">sin(x)</span></code> is continuous; they are returned as a tuple to <code class="docutils literal notranslate"><span class="pre">interval</span></code>.
The final root is found by refining the interval, using <code class="docutils literal notranslate"><span class="pre">gvar.root.refine</span></code>.
By default, the root is refined iteratively to machine precision, but this
requires only a small number (4) of iterations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">nit</span><span class="p">)</span>                             <span class="c1"># number of iterations</span>
<span class="go">4</span>
</pre></div>
</div>
<p>The most challenging situations are ones where the function
is extremely flat in the vicinity of the root — that is,
two or more of its leading derivatives vanish there. For
example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gvar</span> <span class="k">as</span> <span class="nn">gv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">**</span> <span class="mi">11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">refine</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">nit</span><span class="p">)</span>                             <span class="c1"># number of iterations</span>
<span class="go">142</span>
</pre></div>
</div>
<p>This routine also works with variables of type <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code></a>:
for example,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gvar</span> <span class="k">as</span> <span class="nn">gv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">gv</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">refine</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="go">3.14(31)</span>
</pre></div>
</div>
<p>returns a root with a 10% uncertainty, reflecting the
uncertainty in parameter <code class="docutils literal notranslate"><span class="pre">w</span></code>.</p>
<p>Descriptions of the two methods follow.</p>
<dl class="py method">
<dt class="sig sig-object py" id="gvar.root.search">
<span class="sig-prename descclassname"><span class="pre">root.</span></span><span class="sig-name descname"><span class="pre">search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">incr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fac</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">analyzer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.root.search" title="Permalink to this definition">¶</a></dt>
<dd><p>Search for and bracket root of one-dimensional function <code class="docutils literal notranslate"><span class="pre">fcn(x)</span></code>.</p>
<p>This method searches for an interval in <code class="docutils literal notranslate"><span class="pre">x</span></code> that brackets
a root of <code class="docutils literal notranslate"><span class="pre">fcn(x)=0</span></code>. It examines points</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">fac</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">incr</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">x[0]=x0</span></code> and <code class="docutils literal notranslate"><span class="pre">j=0...maxit-1</span></code>, looking for a pair
of successive points where <code class="docutils literal notranslate"><span class="pre">fcn(x[j])</span></code> changes sign. These
points bracket a root (assuming the function is continuous),
providing a coarse estimate of the root. That estimate can
be refined using <a class="reference internal" href="#gvar.root.refine" title="gvar.root.refine"><code class="xref py py-meth docutils literal notranslate"><span class="pre">root.refine()</span></code></a>.</p>
<p class="rubric">Example</p>
<p>The following code seeks to bracket the first zero of
<code class="docutils literal notranslate"><span class="pre">sin(x)</span></code> with <code class="docutils literal notranslate"><span class="pre">x&gt;0.1</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">math</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gvar</span> <span class="k">as</span> <span class="nn">gv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">interval</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>
<span class="go">(3.0912680532870755, 3.4003948586157833)</span>
</pre></div>
</div>
<p>The resulting interval correctly brackets the root
at <code class="docutils literal notranslate"><span class="pre">pi</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fcn</strong> – One dimenionsal function whose root is sought.</p></li>
<li><p><strong>x0</strong> (<em>float</em>) – Starting point for search.</p></li>
<li><p><strong>incr</strong> (<em>float</em><em>, </em><em>optional</em>) – Increment used for linear searches. Default
value is 0.</p></li>
<li><p><strong>fac</strong> (<em>float</em><em>, </em><em>optional</em>) – Rescaling factor for exponential searches.
Default value is 1.1.</p></li>
<li><p><strong>maxit</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of steps allowed for search. An
exception is raised if a root is not found in time. Default
value is 100.</p></li>
<li><p><strong>analyzer</strong> – Optional function <code class="docutils literal notranslate"><span class="pre">f(x,</span> <span class="pre">fcn(x))</span></code> that is called
for each point <code class="docutils literal notranslate"><span class="pre">x</span></code> that is examined. This can be used,
for example, to monitor the search while debugging.
Default is <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>Tuple <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b)</span></code> where <code class="docutils literal notranslate"><span class="pre">fcn(a)</span> <span class="pre">*</span> <span class="pre">fcn(b)</span> <span class="pre">&lt;=</span> <span class="pre">0</span></code>, which implies
that a root occurs between <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> (provided the
function is continuous). The tuple has extra attributes
that provide additional information about the search:</p>
<ul class="simple">
<li><p><strong>nit</strong> — Number of iterations used to find interval <code class="docutils literal notranslate"><span class="pre">(a,b)</span></code>.</p></li>
<li><p><strong>fcnval</strong> — Tuple containing the function values at <code class="docutils literal notranslate"><span class="pre">(a,b)</span></code>.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError</strong> – If unable to find a root in <code class="docutils literal notranslate"><span class="pre">maxit</span></code> steps.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gvar.root.refine">
<span class="sig-prename descclassname"><span class="pre">root.</span></span><span class="sig-name descname"><span class="pre">refine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">interval</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">analyzer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.root.refine" title="Permalink to this definition">¶</a></dt>
<dd><p>Find root <code class="docutils literal notranslate"><span class="pre">x</span></code> of one-dimensional function <code class="docutils literal notranslate"><span class="pre">fcn</span></code> on an interval.</p>
<p>This method finds a root <code class="docutils literal notranslate"><span class="pre">x</span></code> of <code class="docutils literal notranslate"><span class="pre">fcn(x)=0</span></code> inside an <code class="docutils literal notranslate"><span class="pre">interval=(a,b)</span></code>
that brackets the root, with <code class="docutils literal notranslate"><span class="pre">fcn(a)</span> <span class="pre">*</span> <span class="pre">fcn(b)</span> <span class="pre">&lt;=</span> <span class="pre">0</span></code>.</p>
<p>This method is a pure Python adaptation of an algorithm
from Richard Brent’s book “Algorithms for Minimization
without Derivatives” (1973). Being pure Python it works with
<a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code></a>-valued functions and variables.</p>
<p class="rubric">Example</p>
<p>The following code finds a root of <code class="docutils literal notranslate"><span class="pre">sin(x)</span></code> in the interval
<code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">4</span></code>, using 7 iterative refinements of the initial
interval:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">math</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gvar</span> <span class="k">as</span> <span class="nn">gv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">refine</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="go">3.14159265359</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">nit</span><span class="p">)</span>
<span class="go">7</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fcn</strong> – One-dimensional function whose zero/root is sought.</p></li>
<li><p><strong>interval</strong> – Tuple <code class="docutils literal notranslate"><span class="pre">(a,b)</span></code> specifying an interval containing
the root, with <code class="docutils literal notranslate"><span class="pre">fcn(a)</span> <span class="pre">*</span> <span class="pre">fcn(b)</span> <span class="pre">&lt;=</span> <span class="pre">0</span></code>. The search
for a root is confined to this interval.</p></li>
<li><p><strong>rtol</strong> (<em>float</em><em>, </em><em>optional</em>) – Relative tolerance for the root. The default
value is <code class="docutils literal notranslate"><span class="pre">None</span></code>, which sets <code class="docutils literal notranslate"><span class="pre">rtol</span></code> equal to machine
precision (<code class="docutils literal notranslate"><span class="pre">sys.float_info.epsilon</span></code>). A larger value
usually leads to less precision but is faster.</p></li>
<li><p><strong>maxit</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of iterations used to find
a root with the given tolerance. A warning is
issued if the algorithm does not converge in time.
(Default value is 1000.)</p></li>
<li><p><strong>analyzer</strong> – Optional function <code class="docutils literal notranslate"><span class="pre">f(x,</span> <span class="pre">fcn(x))</span></code> that is called
for each point <code class="docutils literal notranslate"><span class="pre">x</span></code> examined by the algorithm. This can
be used, for example, to monitor convergence while
debugging. Default is <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>The root, which is either a <code class="docutils literal notranslate"><span class="pre">float</span></code> or
a <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code></a> but with extra attributes that
provide additional information about the root:</p>
<ul class="simple">
<li><p><strong>nit</strong> — Number of iterations used to find the root.</p></li>
<li><p><strong>interval</strong> — Smallest interval <code class="docutils literal notranslate"><span class="pre">(b,c)</span></code> found containing
the root, where <code class="docutils literal notranslate"><span class="pre">b</span></code> is the root returned by the method.</p></li>
<li><p><strong>fcnval</strong> — Value of <code class="docutils literal notranslate"><span class="pre">fcn(x)</span></code> at the root.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ValueError</strong> – If <code class="docutils literal notranslate"><span class="pre">fcn(a)</span> <span class="pre">*</span> <span class="pre">fcn(b)</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> for initial
    interval <code class="docutils literal notranslate"><span class="pre">(a,b)</span></code>.</p></li>
<li><p><strong>UserWarning</strong> – If the algorithm fails to converge
    after <code class="docutils literal notranslate"><span class="pre">maxit</span></code> iterations.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Numerical Analysis Modules in <code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar</span></code></a><ul>
<li><a class="reference internal" href="#cubic-splines">Cubic Splines</a></li>
<li><a class="reference internal" href="#linear-algebra">Linear Algebra</a></li>
<li><a class="reference internal" href="#ordinary-differential-equations">Ordinary Differential Equations</a></li>
<li><a class="reference internal" href="#one-dimensional-integration">One-Dimensional Integration</a></li>
<li><a class="reference internal" href="#pade-approximants">Pade Approximants</a></li>
<li><a class="reference internal" href="#module-gvar.powerseries">Power Series</a><ul>
<li><a class="reference internal" href="#using-power-series">Using power series</a></li>
<li><a class="reference internal" href="#multivariate-power-series">Multivariate power series</a></li>
<li><a class="reference internal" href="#taylor-expansions-of-python-functions">Taylor expansions of Python functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#root-finding">Root Finding</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="gvar_dataset.html"
                          title="previous chapter"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar.dataset</span></code> - Random Data Sets</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="case-pendulum.html"
                          title="next chapter">Case Study:  Numerical Analysis — Pendulum Clock</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/gvar_other.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="case-pendulum.html" title="Case Study: Numerical Analysis — Pendulum Clock"
             >next</a> |</li>
        <li class="right" >
          <a href="gvar_dataset.html" title="gvar.dataset - Random Data Sets"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">gvar 12.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Numerical Analysis Modules in <code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar</span></code></a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2009-2023, G. P. Lepage.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.0.2.
    </div>
  </body>
</html>