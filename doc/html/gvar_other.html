<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Numerical Analysis Modules in gvar &mdash; gvar 8.3.1 documentation</title>
    
    <link rel="stylesheet" href="_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '8.3.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="gvar 8.3.1 documentation" href="index.html" />
    <link rel="next" title="Case Study: Pendulum Clock" href="case-pendulum.html" />
    <link rel="prev" title="gvar.dataset - Random Data Sets" href="gvar_dataset.html" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head>
  <body role="document">

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="case-pendulum.html" title="Case Study: Pendulum Clock"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="gvar_dataset.html" title="gvar.dataset - Random Data Sets"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">gvar 8.3.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="numerical-analysis-modules-in-gvar">
<span id="id1"></span><h1>Numerical Analysis Modules in <a class="reference internal" href="gvar.html#module-gvar" title="gvar: Correlated Gaussian random variables."><code class="xref py py-mod docutils literal"><span class="pre">gvar</span></code></a><a class="headerlink" href="#numerical-analysis-modules-in-gvar" title="Permalink to this headline">¶</a></h1>
<p><a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s can be used in many numerical algorithms, to propagates errors
through the algorithm. A code that is written in pure Python is likely to
work well with <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s, perhaps with minor modifications.
Here we describe some sample numerical codes, included in
<a class="reference internal" href="gvar.html#module-gvar" title="gvar: Correlated Gaussian random variables."><code class="xref py py-mod docutils literal"><span class="pre">gvar</span></code></a>, that have been adapted
to work with <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s, as well as with <code class="docutils literal"><span class="pre">float</span></code>s.
More examples will follow with time.</p>
<p>The sub-modules included here are:</p>
<blockquote>
<div><ul>
<li><p class="first"><a class="reference internal" href="#module-gvar.cspline" title="gvar.cspline: Cubic splines."><code class="xref py py-mod docutils literal"><span class="pre">gvar.cspline</span></code></a> &#8212; cubic splines for 1-d data.</p>
</li>
<li><p class="first"><a class="reference internal" href="#module-gvar.linalg" title="gvar.linalg: Basic linear algebra."><code class="xref py py-mod docutils literal"><span class="pre">gvar.linalg</span></code></a> &#8212; basic linear algebra.</p>
</li>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#module-gvar.ode" title="gvar.ode: Ordinary differential equations."><code class="xref py py-mod docutils literal"><span class="pre">gvar.ode</span></code></a> &#8212; integration of systems of ordinary differential equations;</dt>
<dd><p class="first last"><a class="reference internal" href="#integral"><span>one-dimensional integrals</span></a>.</p>
</dd>
</dl>
</li>
<li><p class="first"><a class="reference internal" href="#module-gvar.powerseries" title="gvar.powerseries: Power series arithmetic and evaluation."><code class="xref py py-mod docutils literal"><span class="pre">gvar.powerseries</span></code></a> &#8212; power series representation of functions.</p>
</li>
<li><p class="first"><a class="reference internal" href="#module-gvar.root" title="gvar.root: Roots (zeros) of one-dimensional functions."><code class="xref py py-mod docutils literal"><span class="pre">gvar.root</span></code></a> &#8212; root-finding for one-dimensional functions.</p>
</li>
</ul>
</div></blockquote>
<span class="target" id="module-gvar.cspline"></span><div class="section" id="cubic-splines">
<h2>Cubic Splines<a class="headerlink" href="#cubic-splines" title="Permalink to this headline">¶</a></h2>
<p>Module <a class="reference internal" href="#module-gvar.cspline" title="gvar.cspline: Cubic splines."><code class="xref py py-mod docutils literal"><span class="pre">gvar.cspline</span></code></a> implements a class for smoothing and/or
interpolating one-dimensional data using cubic splines:</p>
<dl class="class">
<dt id="gvar.cspline.CSpline">
<em class="property">class </em><code class="descclassname">gvar.cspline.</code><code class="descname">CSpline</code><span class="sig-paren">(</span><em>xknots</em>, <em>yknots</em>, <em>deriv=(None</em>, <em>None)</em>, <em>extrap_order=3</em>, <em>warn=True</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.cspline.CSpline" title="Permalink to this definition">¶</a></dt>
<dd><p>Cubic spline approximation to a function.</p>
<p>Given <code class="docutils literal"><span class="pre">N</span></code> values of a function <code class="docutils literal"><span class="pre">yknot[i]</span></code> at <code class="docutils literal"><span class="pre">N</span></code> points
<code class="docutils literal"><span class="pre">xknot[i]</span></code> for <code class="docutils literal"><span class="pre">i=0..N-1</span></code> (the &#8216;knots&#8217; of the spline),
the code</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">gvar.cspline</span> <span class="kn">import</span> <span class="n">CSpline</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">CSpline</span><span class="p">(</span><span class="n">xknot</span><span class="p">,</span> <span class="n">yknot</span><span class="p">)</span>
</pre></div>
</div>
<p>defines a function <code class="docutils literal"><span class="pre">f</span></code> such that: a) <code class="docutils literal"><span class="pre">f(xknot[i])</span> <span class="pre">=</span> <span class="pre">yknot[i]</span></code> for
all <code class="docutils literal"><span class="pre">i</span></code>; and b) <code class="docutils literal"><span class="pre">f(x)</span></code> is
continuous, as are its first and second derivatives.
Function <code class="docutils literal"><span class="pre">f(x)</span></code> is a cubic polynomial between the knots <code class="docutils literal"><span class="pre">xknot[i]</span></code>.</p>
<p><code class="docutils literal"><span class="pre">CSpline(xknot,</span> <span class="pre">yknot)</span></code> creates a <em>natural spline</em>, which has zero second
derivative at the end points, <code class="docutils literal"><span class="pre">xknot[0]</span></code> and <code class="docutils literal"><span class="pre">xknot[-1]</span></code> (assuming
the knots are sorted). More generally one can specify the derivatives
of <code class="docutils literal"><span class="pre">f(x)</span></code> at one or both of the endpoints:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="n">CSpline</span><span class="p">(</span><span class="n">xknot</span><span class="p">,</span> <span class="n">yknot</span><span class="p">,</span> <span class="n">deriv</span><span class="o">=</span><span class="p">[</span><span class="n">dydx_i</span><span class="p">,</span> <span class="n">dydx_f</span><span class="p">])</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">dydx_i</span></code> is the derivative at <code class="docutils literal"><span class="pre">xknot[0]</span></code> and <code class="docutils literal"><span class="pre">dydx_f</span></code> is the
derivative at <code class="docutils literal"><span class="pre">xknot[-1]</span></code>. Replacing either (or both) of these with
<code class="docutils literal"><span class="pre">None</span></code> results in a derivative corresponding to zero second
derivative at that boundary (i.e., a <em>natural</em> boundary).</p>
<p>Derivatives and integrals of the spline function can also be evaluated:</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">f.D(x)</span></code> &#8212; first derivative at <code class="docutils literal"><span class="pre">x</span></code>;</p>
<p><code class="docutils literal"><span class="pre">f.D2(x)</span></code> &#8212; second derivative at <code class="docutils literal"><span class="pre">x</span></code>;</p>
<p><code class="docutils literal"><span class="pre">f.integ(x)</span></code> &#8212; integral from <code class="docutils literal"><span class="pre">xknot[0]</span></code> to <code class="docutils literal"><span class="pre">x</span></code>.</p>
</div></blockquote>
<p>Splines can be used outside the range covered by the defining
<code class="docutils literal"><span class="pre">xknot</span></code> values. As this is often a bad idea, the <code class="xref py py-mod docutils literal"><span class="pre">CSpline</span></code>
methods issue a warning when called with out-of-range points.
The warning can be suppressed by setting parameter <code class="docutils literal"><span class="pre">warn=False</span></code>.
The spline value for an out-of-range point is calculated
using a polynomial whose value and derivatives match those of the spline
at the knot closest to the out-of-range point. The extrapolation
polynomial is cubic by default, but lower orders can be specified by
setting parameter <code class="docutils literal"><span class="pre">extrap_order</span></code> to a (non-negative) integer
less than 3; this is often a good idea.</p>
<p class="rubric">Examples</p>
<p>Typical usage is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">math</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gvar</span> <span class="kn">as</span> <span class="nn">gv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xknot</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.78539816</span><span class="p">,</span> <span class="mf">1.57079633</span><span class="p">,</span> <span class="mf">2.35619449</span><span class="p">,</span> <span class="mf">3.14159265</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yknot</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.70710678</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.70710678</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">cspline</span><span class="o">.</span><span class="n">CSpline</span><span class="p">(</span><span class="n">xknot</span><span class="p">,</span> <span class="n">yknot</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mf">0.7</span><span class="p">),</span> <span class="n">f</span><span class="o">.</span><span class="n">D</span><span class="p">(</span><span class="mf">0.7</span><span class="p">),</span> <span class="n">f</span><span class="o">.</span><span class="n">D2</span><span class="p">(</span><span class="mf">0.7</span><span class="p">),</span> <span class="n">f</span><span class="o">.</span><span class="n">integ</span><span class="p">(</span><span class="mf">0.7</span><span class="p">))</span>
<span class="go">0.644243383101 0.765592448296 -0.663236750777 0.234963942648</span>
</pre></div>
</div>
<p>Here the <code class="docutils literal"><span class="pre">yknot</span></code> values were obtained by taking <code class="docutils literal"><span class="pre">sin(xknot)</span></code>.
Tabulating results from the spline together with the exact results
shows that this 5-knot spline gives a pretty good approximation
of the function <code class="docutils literal"><span class="pre">sin(x)</span></code>, as well as its derivatives and integral:</p>
<div class="highlight-python"><div class="highlight"><pre>x    f(x)    f.D(x)  f.D2(x) f.integ(x) | sin(x)  cos(x)  1-cos(x)
------------------------------------------------------------------
0.3  0.2951  0.9551  -0.2842 0.04458    | 0.2955  0.9553  0.04466
0.5  0.4791  0.8793  -0.4737 0.1222     | 0.4794  0.8776  0.1224
0.7  0.6442  0.7656  -0.6632 0.235      | 0.6442  0.7648  0.2352
0.9  0.783   0.6176  -0.7891 0.3782     | 0.7833  0.6216  0.3784
1.1  0.8902  0.452   -0.8676 0.5461     | 0.8912  0.4536  0.5464
1.3  0.9627  0.2706  -0.9461 0.7319     | 0.9636  0.2675  0.7325
1.5  0.9974  0.07352 -1.025  0.9286     | 0.9975  0.07074 0.9293
</pre></div>
</div>
<p>Using the spline outside
the range covered by the knots is less good:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
<span class="go">gvar/cspline.py:164: UserWarning: x outside of spline range: [ 6.28318531]</span>
<span class="go">1.7618635470106501</span>
</pre></div>
</div>
<p>The correct answer is 0.0, of course. This is why the spline function
issues a warning. Working just outside the knot region is often fine,
although it is usually a good idea to limit the order of the
polynomial used in such regions: for example, setting</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">cspline</span><span class="o">.</span><span class="n">CSpline</span><span class="p">(</span><span class="n">xknot</span><span class="p">,</span> <span class="n">yknot</span><span class="p">,</span> <span class="n">extrap_order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>implies that quadratic polynomials are used outside the spline range.
Finally one can specify the values of the first derivatives of the
function at one or the other endpoints of the spline region, if they
are known. Continuing from above, for example, one would take</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">cspline</span><span class="o">.</span><span class="n">CSpline</span><span class="p">(</span><span class="n">xknot</span><span class="p">,</span> <span class="n">yknot</span><span class="p">,</span> <span class="n">deriv</span><span class="o">=</span><span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">])</span>
</pre></div>
</div>
<p>since the derivatives of <code class="docutils literal"><span class="pre">sin(x)</span></code> at <code class="docutils literal"><span class="pre">x=0</span></code> and <code class="docutils literal"><span class="pre">x=3.14159265</span></code>
are 1 and -1, respectively.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>xknot</strong> (<em>1-d sequence of number</em>) &#8211; The knots of the spline, where the
function values are specified. The knots are sorted (from small
to large) if necessary.</li>
<li><strong>yknot</strong> (<em>1-d sequence of number</em>) &#8211; Function values at the locations
specified by <code class="docutils literal"><span class="pre">xknot[i]</span></code>.</li>
<li><strong>deriv</strong> (<em>2-component sequence</em>) &#8211; Derivatives at initial and final
boundaries of the  region specified by <code class="docutils literal"><span class="pre">xknot[i]</span></code>.
Default value is <code class="docutils literal"><span class="pre">None</span></code> for each boundary.</li>
<li><strong>extrap_order</strong> (<em>int</em>) &#8211; Order of polynomial used for extrapolations
outside of the spline range. The polynomial is constructed from
the spline&#8217;s value and derivatives at the (nearest) knot of the
spline. The allowed range is <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">extrap_order</span> <span class="pre">&lt;=</span> <span class="pre">3</span></code>. The
default value is 3 although it is common practice to use
smaller values.</li>
<li><strong>warn</strong> (<em>bool</em>) &#8211; If <code class="docutils literal"><span class="pre">True</span></code>, warnings are generated
when the spline function is called for <code class="docutils literal"><span class="pre">x</span></code> values that
fall outside of the original range of <code class="docutils literal"><span class="pre">xknot</span></code>s used to
define the spline. Default value is <code class="docutils literal"><span class="pre">True</span></code>;
out-of-range warnings are suppressed if set to <code class="docutils literal"><span class="pre">False</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-gvar.linalg"></span></div>
<div class="section" id="linear-algebra">
<h2>Linear Algebra<a class="headerlink" href="#linear-algebra" title="Permalink to this headline">¶</a></h2>
<p>Module <a class="reference internal" href="#module-gvar.linalg" title="gvar.linalg: Basic linear algebra."><code class="xref py py-mod docutils literal"><span class="pre">gvar.linalg</span></code></a> implements several methods for doing basic
linear algebra with matrices whose elements can be either numbers or
<a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s:</p>
<dl class="method">
<dt id="gvar.linalg.det">
<code class="descclassname">linalg.</code><code class="descname">det</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.linalg.det" title="Permalink to this definition">¶</a></dt>
<dd><p>Determinant of matrix <code class="docutils literal"><span class="pre">a</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>a</strong> &#8211; Two-dimensional, square matrix/array of numbers
and/or <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Deterimant of the matrix.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code> &#8211;
If matrix is not square and two-dimensional.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gvar.linalg.slogdet">
<code class="descclassname">linalg.</code><code class="descname">slogdet</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.linalg.slogdet" title="Permalink to this definition">¶</a></dt>
<dd><p>Sign and logarithm of determinant of matrix <code class="docutils literal"><span class="pre">a</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>a</strong> &#8211; Two-dimensional, square matrix/array of numbers
and/or <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Tuple <code class="docutils literal"><span class="pre">(s,</span> <span class="pre">logdet)</span></code> where the determinant of matrix <code class="docutils literal"><span class="pre">a</span></code> is
<code class="docutils literal"><span class="pre">s</span> <span class="pre">*</span> <span class="pre">exp(logdet)</span></code>.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code> &#8211;
If matrix is not square and two-dimensional.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gvar.linalg.inv">
<code class="descclassname">linalg.</code><code class="descname">inv</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.linalg.inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse of matrix <code class="docutils literal"><span class="pre">a</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>a</strong> &#8211; Two-dimensional, square matrix/array of numbers
and/or <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The inverse of matrix <code class="docutils literal"><span class="pre">a</span></code>.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code> &#8211;
If matrix is not square and two-dimensional.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gvar.linalg.solve">
<code class="descclassname">linalg.</code><code class="descname">solve</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.linalg.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Find <code class="docutils literal"><span class="pre">x</span></code> such that <code class="docutils literal"><span class="pre">a.dot(x)</span> <span class="pre">=</span> <span class="pre">b</span></code> for matrix <code class="docutils literal"><span class="pre">a</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> &#8211; Two-dimensional, square matrix/array of numbers
and/or <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s.</li>
<li><strong>b</strong> &#8211; One-dimensional vector/array of numbers and/or
<a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s, or an array of such vectors.
Requires <code class="docutils literal"><span class="pre">b.shape[0]</span> <span class="pre">==</span> <span class="pre">a.shape[1]</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The solution <code class="docutils literal"><span class="pre">x</span></code> of <code class="docutils literal"><span class="pre">a.dot(x)</span> <span class="pre">=</span> <span class="pre">b</span></code>, which is equivalent
to <code class="docutils literal"><span class="pre">inv(a).dot(b)</span></code>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code> &#8211;
If <code class="docutils literal"><span class="pre">a</span></code> is not square and two-dimensional.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code> &#8211;
If shape of <code class="docutils literal"><span class="pre">b</span></code> does not match that of <code class="docutils literal"><span class="pre">a</span></code>
(that is <code class="docutils literal"><span class="pre">b.shape[0]</span> <span class="pre">!=</span> <span class="pre">a.shape[1]</span></code>).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gvar.linalg.eigvalsh">
<code class="descclassname">linalg.</code><code class="descname">eigvalsh</code><span class="sig-paren">(</span><em>a</em>, <em>eigvec=False</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.linalg.eigvalsh" title="Permalink to this definition">¶</a></dt>
<dd><p>Eigenvalues of Hermitian matrix <code class="docutils literal"><span class="pre">a</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> &#8211; Two-dimensional, square matrix/array of numbers
and/or <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>s.</li>
<li><strong>eigvec</strong> (<em>bool</em>) &#8211; If <code class="docutils literal"><span class="pre">True</span></code>, method returns a tuple of arrays
<code class="docutils literal"><span class="pre">(val,</span> <span class="pre">vec)</span></code> where the <code class="docutils literal"><span class="pre">val[i]</span></code> are the
eigenvalues. Arrays <code class="docutils literal"><span class="pre">vec[:,</span> <span class="pre">i]</span></code> are the corresponding
eigenvectors of <code class="docutils literal"><span class="pre">a</span></code> when one ignores uncertainties (that is,
they are eigenvectors of <code class="docutils literal"><span class="pre">gvar.mean(a)</span></code>). Only <code class="docutils literal"><span class="pre">val</span></code> is
returned if <code class="docutils literal"><span class="pre">eigvec=False</span></code> (default).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Array of eigenvalues of matrix <code class="docutils literal"><span class="pre">a</span></code> if parameter
<code class="docutils literal"><span class="pre">eigvec==False</span></code> (default).  where the <code class="docutils literal"><span class="pre">val[i]</span></code> are the
eigenvalues; otherwise it returns a tuple of arrays <code class="docutils literal"><span class="pre">(val,</span> <span class="pre">vec)</span></code>
where the <code class="docutils literal"><span class="pre">val[i]</span></code> are the eigenvalues. Arrays <code class="docutils literal"><span class="pre">vec[:,</span> <span class="pre">i]</span></code> are
the corresponding eigenvectors of <code class="docutils literal"><span class="pre">a</span></code> when one ignores
uncertainties (that is, they are eigenvectors of <code class="docutils literal"><span class="pre">gvar.mean(a)</span></code>).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code> &#8211;
If matrix is not square and two-dimensional.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-gvar.ode"></span></div>
<div class="section" id="ordinary-differential-equations">
<h2>Ordinary Differential Equations<a class="headerlink" href="#ordinary-differential-equations" title="Permalink to this headline">¶</a></h2>
<p>Module <a class="reference internal" href="#module-gvar.ode" title="gvar.ode: Ordinary differential equations."><code class="xref py py-mod docutils literal"><span class="pre">gvar.ode</span></code></a> implements two classes for integrating systems
of first-order differential equations using an adaptive Runge-Kutta
algorithm. One integrates scalar- or array-valued equations, while the
other integrates dictionary-valued equations:</p>
<dl class="class">
<dt id="gvar.ode.Integrator">
<em class="property">class </em><code class="descclassname">gvar.ode.</code><code class="descname">Integrator</code><span class="sig-paren">(</span><em>deriv</em>, <em>tol=1e-05</em>, <em>h=None</em>, <em>hmin=None</em>, <em>analyzer=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.ode.Integrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrate <code class="docutils literal"><span class="pre">dy/dx</span> <span class="pre">=</span> <span class="pre">deriv(x,y)</span></code>.</p>
<p>An <a class="reference internal" href="#gvar.ode.Integrator" title="gvar.ode.Integrator"><code class="xref py py-class docutils literal"><span class="pre">Integrator</span></code></a> object <code class="docutils literal"><span class="pre">odeint</span></code> integrates <code class="docutils literal"><span class="pre">dy/dx</span> <span class="pre">=</span> <span class="pre">f(x,y)</span></code>
to obtain <code class="docutils literal"><span class="pre">y(x1)</span></code> from <code class="docutils literal"><span class="pre">y0</span> <span class="pre">=</span> <span class="pre">y(x0)</span></code>. <code class="docutils literal"><span class="pre">y</span></code> and <code class="docutils literal"><span class="pre">f(x,y)</span></code> can
be scalars or <code class="xref py py-mod docutils literal"><span class="pre">numpy</span></code> arrays. Typical usage is illustrated
by the following code for integrating <code class="docutils literal"><span class="pre">dy/dx</span> <span class="pre">=</span> <span class="pre">y</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">gvar.ode</span> <span class="kn">import</span> <span class="n">Integrator</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">y</span>

<span class="n">odeint</span> <span class="o">=</span> <span class="n">Integrator</span><span class="p">(</span><span class="n">deriv</span><span class="o">=</span><span class="n">f</span><span class="p">,</span>  <span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">)</span>
<span class="n">y0</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="n">y1</span> <span class="o">=</span> <span class="n">odeint</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.</span><span class="p">))</span>
<span class="n">y2</span> <span class="o">=</span> <span class="n">odeint</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">))</span>
<span class="o">...</span>
</pre></div>
</div>
<p>Here the first call to <code class="docutils literal"><span class="pre">odeint</span></code> integrates the differential equation
from <code class="docutils literal"><span class="pre">x=0</span></code> to <code class="docutils literal"><span class="pre">x=1</span></code> starting with <code class="docutils literal"><span class="pre">y=y0</span></code> at <code class="docutils literal"><span class="pre">x=0</span></code>; the result
is <code class="docutils literal"><span class="pre">y1=exp(1)</span></code>, of course. Similarly the second call to <code class="docutils literal"><span class="pre">odeint</span></code>
continues the integration from <code class="docutils literal"><span class="pre">x=1</span></code> to <code class="docutils literal"><span class="pre">x=2</span></code>, giving <code class="docutils literal"><span class="pre">y2=exp(2)</span></code>.</p>
<p>If the <code class="docutils literal"><span class="pre">interval</span></code> is a list with more than two entries,
then <code class="docutils literal"><span class="pre">odeint(y0,</span> <span class="pre">interval=[x0,</span> <span class="pre">x1,</span> <span class="pre">x2</span> <span class="pre">...])</span></code> in the example above
returns an array of solutions for points <code class="docutils literal"><span class="pre">x1,</span> <span class="pre">x2</span> <span class="pre">...</span></code>. So the example
above could have been written equivalently as</p>
<div class="highlight-python"><div class="highlight"><pre>...

odeint = Integrator(deriv=f,  tol=1e-8)
y0 = 1.
y1, y2 ... = odeint(y0, interval=[0, 1., 2. ...])
</pre></div>
</div>
<p>An alternative interface creates a new function which is the
solution of the differential equation for specific initial conditions.
The code above could be rewritten:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x0</span> <span class="o">=</span> <span class="mf">0.</span>         <span class="c"># initial conditions</span>
<span class="n">y0</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">Integrator</span><span class="p">(</span><span class="n">deriv</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">)</span><span class="o">.</span><span class="n">solution</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">)</span>
<span class="n">y1</span> <span class="o">=</span> <span class="n">y</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">y2</span> <span class="o">=</span> <span class="n">y</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
<p>Here method <code class="xref py py-meth docutils literal"><span class="pre">Integrator.solution()</span></code> returns a function <code class="docutils literal"><span class="pre">y(x)</span></code>
where: a) <code class="docutils literal"><span class="pre">y(x0)</span> <span class="pre">=</span> <span class="pre">y0</span></code>; and b) <code class="docutils literal"><span class="pre">y(x)</span></code> uses the integator to
integrate the differential equation to point <code class="docutils literal"><span class="pre">x</span></code> starting
from  the last point at which <code class="docutils literal"><span class="pre">y</span></code> was evaluated
(or from <code class="docutils literal"><span class="pre">x0</span></code> for the first call to <code class="docutils literal"><span class="pre">y(x)</span></code>). The function can
also be called with an array of <code class="docutils literal"><span class="pre">x</span></code> values, in which case an
array containing the corresponding <code class="docutils literal"><span class="pre">y</span></code> values is returned.</p>
<p>The integrator uses an adaptive Runge-Kutta algorithm that adjusts
the integrator&#8217;s step size to obtain relative accuracy <code class="docutils literal"><span class="pre">tol</span></code> in the solution.
An initial step size can be set in the <a class="reference internal" href="#gvar.ode.Integrator" title="gvar.ode.Integrator"><code class="xref py py-class docutils literal"><span class="pre">Integrator</span></code></a> by specifying
parameter <code class="docutils literal"><span class="pre">h</span></code>. A minimum step size <code class="docutils literal"><span class="pre">hmin</span></code> can also be specified;
the <a class="reference internal" href="#gvar.ode.Integrator" title="gvar.ode.Integrator"><code class="xref py py-class docutils literal"><span class="pre">Integrator</span></code></a> raises an exception if the step size becomes
smaller than <code class="docutils literal"><span class="pre">hmin</span></code>. The <a class="reference internal" href="#gvar.ode.Integrator" title="gvar.ode.Integrator"><code class="xref py py-class docutils literal"><span class="pre">Integrator</span></code></a> keeps track of the
number of good steps, where <code class="docutils literal"><span class="pre">h</span></code> is increased, and the number of
bad steps, where <code class="docutils literal"><span class="pre">h</span></code> is decreased and the step is repeated:
<code class="docutils literal"><span class="pre">odeint.ngood</span></code> and <code class="docutils literal"><span class="pre">odeint.nbad</span></code>, respectively.</p>
<p>A custom criterion for step-size changes can be implemented by
specifying a function for parameter delta. This is a function
<code class="docutils literal"><span class="pre">delta(yerr,</span> <span class="pre">y,</span> <span class="pre">delta_y)</span></code> &#8212; of the estimated error <code class="docutils literal"><span class="pre">yerr</span></code>
after a given step, the proposed value for <code class="docutils literal"><span class="pre">y</span></code>, and the
proposed change <code class="docutils literal"><span class="pre">delta_y</span></code> in <code class="docutils literal"><span class="pre">y</span></code> &#8212; that returns a number
to compare with tolerance <code class="docutils literal"><span class="pre">tol</span></code>. The step size is
decreased and the step repeated if <code class="docutils literal"><span class="pre">delta(yerr,</span> <span class="pre">y,</span> <span class="pre">delta_y)</span> <span class="pre">&gt;</span> <span class="pre">tol</span></code>;
otherwise the step is accepted and the step size increased.
The default definition of <code class="docutils literal"><span class="pre">delta</span></code> is roughly equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">gvar</span> <span class="kn">as</span> <span class="nn">gv</span>

<span class="k">def</span> <span class="nf">delta</span><span class="p">(</span><span class="n">yerr</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">delta_y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">yerr</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">delta_y</span><span class="p">)</span> <span class="o">+</span> <span class="n">gv</span><span class="o">.</span><span class="n">ode</span><span class="o">.</span><span class="n">TINY</span><span class="p">)</span>
        <span class="p">)</span>
</pre></div>
</div>
<p>A custom definition can be used to allow an <code class="docutils literal"><span class="pre">Integrator</span></code> to
work with data types other than floats or <code class="xref py py-mod docutils literal"><span class="pre">numpy</span></code> arrays of floats.
All that is required of the data type is that it support
ordinary arithmetic. Therefore, for example, defining
<code class="docutils literal"><span class="pre">delta(yerr,</span> <span class="pre">y,</span> <span class="pre">delta_y)</span></code> with <code class="docutils literal"><span class="pre">np.abs()</span></code> instead of <code class="docutils literal"><span class="pre">np.fabs()</span></code>
allows <code class="docutils literal"><span class="pre">y</span></code> to be complex valued. (Actually the default <code class="docutils literal"><span class="pre">delta</span></code>
allows this as well.)</p>
<p>An analyzer <code class="docutils literal"><span class="pre">analyzer(x,y)</span></code> can be specified using parameter
<code class="docutils literal"><span class="pre">analyzer</span></code>. This function is called after every full step of
the integration, with the current values of <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code>.
Objects of type <a class="reference internal" href="#gvar.ode.Solution" title="gvar.ode.Solution"><code class="xref py py-class docutils literal"><span class="pre">gvar.ode.Solution</span></code></a> are examples of
(simple) analyzers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>deriv</strong> &#8211; Function of <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code> that returns <code class="docutils literal"><span class="pre">dy/dx</span></code>.
The return value should have the same shape as <code class="docutils literal"><span class="pre">y</span></code> if arrays
are used.</li>
<li><strong>tol</strong> (<em>float</em>) &#8211; Relative accuracy in <code class="docutils literal"><span class="pre">y</span></code> relative to <code class="docutils literal"><span class="pre">|y|</span> <span class="pre">+</span> <span class="pre">h|dy/dx|</span></code>
for each step in the integration. Any integration step that achieves
less precision is repeated with a smaller step size. The step size
is increased if precision is higher than needed. Default is 1e-5.</li>
<li><strong>h</strong> (<em>float or None</em>) &#8211; Absolute value of initial step size. The default value equals the
entire width of the integration interval.</li>
<li><strong>hmin</strong> (<em>float or None</em>) &#8211; Smallest step size allowed. A warning is raised
if a smaller step size is requested, and the step size is not
decreased. This prevents infinite loops at singular points, but
the solution may not be reliable when a warning has been issued. The
default value is <code class="docutils literal"><span class="pre">None</span></code> (which does <em>not</em> prevent infinite loops).</li>
<li><strong>delta</strong> &#8211; Function <code class="docutils literal"><span class="pre">delta(yerr,</span> <span class="pre">y,</span> <span class="pre">delta_y)</span></code> that returns
a number to be compared  with <code class="docutils literal"><span class="pre">tol</span></code> at each integration step:
if it is larger than <code class="docutils literal"><span class="pre">tol</span></code>, the step is repeated with a smaller
step size; if it is smaller the step is accepted and a larger
step size used for the subsequent step. Here <code class="docutils literal"><span class="pre">yerr</span></code> is an
estimate of the error in <code class="docutils literal"><span class="pre">y</span></code> on the last step; <code class="docutils literal"><span class="pre">y</span></code> is the
proposed value; and <code class="docutils literal"><span class="pre">delta_y</span></code> is the change in <code class="docutils literal"><span class="pre">y</span></code> over
the last step.</li>
<li><strong>analyzer</strong> &#8211; Function of <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code> that is called after each
step of the integration. This can be used to analyze intermediate
results.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="gvar.ode.DictIntegrator">
<em class="property">class </em><code class="descclassname">gvar.ode.</code><code class="descname">DictIntegrator</code><span class="sig-paren">(</span><em>deriv</em>, <em>tol=1e-05</em>, <em>h=None</em>, <em>hmin=None</em>, <em>analyzer=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.ode.DictIntegrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrate <code class="docutils literal"><span class="pre">dy/dx</span> <span class="pre">=</span> <span class="pre">deriv(x,y)</span></code> where <code class="docutils literal"><span class="pre">y</span></code> is a dictionary.</p>
<p>An <a class="reference internal" href="#gvar.ode.DictIntegrator" title="gvar.ode.DictIntegrator"><code class="xref py py-class docutils literal"><span class="pre">DictIntegrator</span></code></a> object <code class="docutils literal"><span class="pre">odeint</span></code> integrates <code class="docutils literal"><span class="pre">dy/dx</span> <span class="pre">=</span> <span class="pre">f(x,y)</span></code>
to obtain <code class="docutils literal"><span class="pre">y(x1)</span></code> from <code class="docutils literal"><span class="pre">y0</span> <span class="pre">=</span> <span class="pre">y(x0)</span></code>. <code class="docutils literal"><span class="pre">y</span></code> and <code class="docutils literal"><span class="pre">f(x,y)</span></code> are
dictionary types having the same keys, and containing scalars
and/or <code class="xref py py-mod docutils literal"><span class="pre">numpy</span></code> arrays as values. Typical usage is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">gvar.ode</span> <span class="kn">import</span> <span class="n">DictIntegrator</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="o">...</span>

<span class="n">odeint</span> <span class="o">=</span> <span class="n">DictIntegrator</span><span class="p">(</span><span class="n">deriv</span><span class="o">=</span><span class="n">f</span><span class="p">,</span>  <span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">)</span>
<span class="n">y1</span> <span class="o">=</span> <span class="n">odeint</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">))</span>
<span class="n">y2</span> <span class="o">=</span> <span class="n">odeint</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">))</span>
<span class="o">...</span>
</pre></div>
</div>
<p>The first call to <code class="docutils literal"><span class="pre">odeint</span></code> integrates from <code class="docutils literal"><span class="pre">x=x0</span></code> to <code class="docutils literal"><span class="pre">x=x1</span></code>,
returning <code class="docutils literal"><span class="pre">y1=y(x1)</span></code>. The second call continues the integration
to <code class="docutils literal"><span class="pre">x=x2</span></code>, returning <code class="docutils literal"><span class="pre">y2=y(x2)</span></code>. Multiple integration points
can be specified in <code class="docutils literal"><span class="pre">interval</span></code>, in which case a list of the
corresponding <code class="docutils literal"><span class="pre">y</span></code> values is returned: for example,</p>
<div class="highlight-python"><div class="highlight"><pre>odeint = DictIntegrator(deriv=f,  tol=1e-8)
y1, y2 ... = odeint(y0, interval=[x0, x1, x2 ...])
</pre></div>
</div>
<p>The integrator uses an adaptive Runge-Kutta algorithm that adjusts
the integrator&#8217;s step size to obtain relative accuracy <code class="docutils literal"><span class="pre">tol</span></code> in the solution.
An initial step size can be set in the <a class="reference internal" href="#gvar.ode.DictIntegrator" title="gvar.ode.DictIntegrator"><code class="xref py py-class docutils literal"><span class="pre">DictIntegrator</span></code></a> by specifying
parameter <code class="docutils literal"><span class="pre">h</span></code>. A minimum ste psize <code class="docutils literal"><span class="pre">hmin</span></code> can also be specified;
the <a class="reference internal" href="#gvar.ode.Integrator" title="gvar.ode.Integrator"><code class="xref py py-class docutils literal"><span class="pre">Integrator</span></code></a> raises an exception if the step size becomes
smaller than <code class="docutils literal"><span class="pre">hmin</span></code>. The <a class="reference internal" href="#gvar.ode.DictIntegrator" title="gvar.ode.DictIntegrator"><code class="xref py py-class docutils literal"><span class="pre">DictIntegrator</span></code></a> keeps track of the
number of good steps, where <code class="docutils literal"><span class="pre">h</span></code> is increased, and the number of
bad steps, where <code class="docutils literal"><span class="pre">h</span></code> is decreases and the step is repeated:
<code class="docutils literal"><span class="pre">odeint.ngood</span></code> and <code class="docutils literal"><span class="pre">odeint.nbad</span></code>, respectively.</p>
<p>An analyzer <code class="docutils literal"><span class="pre">analyzer(x,y)</span></code> can be specified using parameter
<code class="docutils literal"><span class="pre">analyzer</span></code>. This function is called after every full step of
the integration with the current values of <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code>.
Objects of type <a class="reference internal" href="#gvar.ode.Solution" title="gvar.ode.Solution"><code class="xref py py-class docutils literal"><span class="pre">gvar.ode.Solution</span></code></a> are examples of
(simple) analyzers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>deriv</strong> &#8211; Function of <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code> that returns <code class="docutils literal"><span class="pre">dy/dx</span></code>.
The return value should be a dictionary with the same
keys as <code class="docutils literal"><span class="pre">y</span></code>, and values that have the same
shape as the corresponding values in <code class="docutils literal"><span class="pre">y</span></code>.</li>
<li><strong>tol</strong> (<em>float</em>) &#8211; Relative accuracy in <code class="docutils literal"><span class="pre">y</span></code> relative to <code class="docutils literal"><span class="pre">|y|</span> <span class="pre">+</span> <span class="pre">h|dy/dx|</span></code>
for each step in the integration. Any integration step that achieves
less precision is repeated with a smaller step size. The step size
is increased if precision is higher than needed.</li>
<li><strong>h</strong> (<em>float</em>) &#8211; Absolute value of initial step size. The default value equals the
entire width of the integration interval.</li>
<li><strong>hmin</strong> (<em>float</em>) &#8211; Smallest step size allowed. A warning is raised
if a smaller step size is requested, and the step size is not
decreased. This prevents infinite loops at singular points, but
the solution may not be reliable when a warning has been issued. The
default value is <code class="docutils literal"><span class="pre">None</span></code> (which does <em>not</em> prevent infinite loops).</li>
<li><strong>analyzer</strong> &#8211; Function of <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code> that is called after each
step of the integration. This can be used to analyze intermediate
results.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>A simple analyzer class is:</p>
<dl class="class">
<dt id="gvar.ode.Solution">
<em class="property">class </em><code class="descclassname">gvar.ode.</code><code class="descname">Solution</code><a class="headerlink" href="#gvar.ode.Solution" title="Permalink to this definition">¶</a></dt>
<dd><p>ODE analyzer for storing intermediate values.</p>
<p>Usage: eg, given</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">odeint</span> <span class="o">=</span> <span class="n">Integrator</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">soln</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="n">y0</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">odeint</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">analyzer</span><span class="o">=</span><span class="n">soln</span><span class="p">)</span>
</pre></div>
</div>
<p>then the <code class="docutils literal"><span class="pre">soln.x[i]</span></code> are the points at which the integrator
evaluated the solution, and <code class="docutils literal"><span class="pre">soln.y[i]</span></code> is the solution
of the differential equation at that point.</p>
</dd></dl>

</div>
<div class="section" id="one-dimensional-integration">
<span id="integral"></span><h2>One-Dimensional Integration<a class="headerlink" href="#one-dimensional-integration" title="Permalink to this headline">¶</a></h2>
<p>Module <a class="reference internal" href="#module-gvar.ode" title="gvar.ode: Ordinary differential equations."><code class="xref py py-mod docutils literal"><span class="pre">gvar.ode</span></code></a> also provides a method for evaluating
one-dimensional integrals (using its adaptive Runge-Kutta algorithm):</p>
<dl class="method">
<dt id="gvar.ode.integral">
<code class="descclassname">ode.</code><code class="descname">integral</code><span class="sig-paren">(</span><em>fcn</em>, <em>interval</em>, <em>fcnshape=None</em>, <em>tol=1e-08</em>, <em>hmin=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.ode.integral" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute integral of <code class="docutils literal"><span class="pre">fcn(x)</span></code> on interval.</p>
<p>Given a function <code class="docutils literal"><span class="pre">fcn(x)</span></code> the call</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">result</span> <span class="o">=</span> <span class="n">integral</span><span class="p">(</span><span class="n">fcn</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">))</span>
</pre></div>
</div>
<p>calculates the integral of <code class="docutils literal"><span class="pre">fcn(x)</span></code> from <code class="docutils literal"><span class="pre">x0</span></code> to <code class="docutils literal"><span class="pre">x1</span></code>.
For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">fcn</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>   <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">integral</span><span class="p">(</span><span class="n">fcn</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">0.500000002834</span>
</pre></div>
</div>
<p>Function <code class="docutils literal"><span class="pre">fcn(x)</span></code> can return a scalar or an array (any shape):
for example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">fcn</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>   <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="p">])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">integral</span><span class="p">(</span><span class="n">fcn</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">[1. 0.5 0.25]</span>
</pre></div>
</div>
<p>The function can also return dictionaries whose values are
scalars or arrays: for example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">fcn</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>   <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">x3</span><span class="o">=</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">integral</span><span class="p">(</span><span class="n">fcn</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">{&#39;x&#39;: 0.5,&#39;x3&#39;: 0.25}</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fcn</strong> &#8211; Function of scalar variable <code class="docutils literal"><span class="pre">x</span></code> that returns the integrand.
The return value should be either a scalar or an array, or a
dictionary whose values are scalars and/or arrays.</li>
<li><strong>interval</strong> &#8211; Contains the interval <code class="docutils literal"><span class="pre">(x0,x1)</span></code> over which the integral
is computed.</li>
<li><strong>fcnshape</strong> &#8211; Contains the shape of the array returned by <code class="docutils literal"><span class="pre">f(x)</span></code> or
<code class="docutils literal"><span class="pre">()</span></code> if the function returns a scalar. Setting <code class="docutils literal"><span class="pre">fshape=None</span></code>
(the default) results in an extra function evaluation to determine
the shape.</li>
<li><strong>tol</strong> &#8211; Relative accuracy of result.</li>
<li><strong>hmin</strong> &#8211; Smallest step size allowed in adaptive integral. A warning is
raised if a smaller step size is requested, and the step size is not
decreased. This prevents infinite loops at singular points, but
the integral may not be accurate when a warning has been issued. The
default value is <code class="docutils literal"><span class="pre">None</span></code> (which does <em>not</em> prevent infinite loops).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-gvar.powerseries">
<span id="power-series"></span><h2>Power Series<a class="headerlink" href="#module-gvar.powerseries" title="Permalink to this headline">¶</a></h2>
<p>Module <a class="reference internal" href="#module-gvar.powerseries" title="gvar.powerseries: Power series arithmetic and evaluation."><code class="xref py py-mod docutils literal"><span class="pre">gvar.powerseries</span></code></a> provides tools for manipulating power series
approximations of functions. A function&#8217;s power series is specified by the
coefficients in its Taylor expansion with respect to an independent variable,
say <code class="docutils literal"><span class="pre">x</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>f(x) = f(0) + f&#39;(0)*x + (f&#39;&#39;(0)/2)*x**2 + (f&#39;&#39;&#39;(0)/6)*x**3 + ...
     = f0 + f1*x + f2*x**2 + f3*x**3 + ...
</pre></div>
</div>
<p>In practice a power series is different from a polynomial because power
series, while infinite order in principle, are truncated at some finite
order in numerical applications. The <code class="docutils literal"><span class="pre">order</span></code> of a power series is the
highest power of <code class="docutils literal"><span class="pre">x</span></code> that is retained in the approximation; coefficients
for still higher-order terms are assumed to be unknown (as opposed to zero).</p>
<p>Taylor&#8217;s theorem can be used to generate power series for functions of
power series:</p>
<div class="highlight-python"><div class="highlight"><pre>g(f(x)) = g(f0) + g&#39;(f0)*(f(x)-f0) + (g&#39;&#39;(f0)/2)*(f(x)-f0)**2 + ...
        = g0 + g1*x + g2*x**2 + ...
</pre></div>
</div>
<p>This allows us to define a full calculus for power series, where arithmetic
expressions and (sufficiently differentiable) functions of power series
return new power series.</p>
<div class="section" id="power-series-arithmetic">
<h3>Power series arithmetic<a class="headerlink" href="#power-series-arithmetic" title="Permalink to this headline">¶</a></h3>
<p>Class <a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal"><span class="pre">PowerSeries</span></code></a> provides a numerical implementation of the power series
calculus. <code class="docutils literal"><span class="pre">PowerSeries([f0,f1,f2,f3...])</span></code> is a numerical representation of
a power series with coefficients <code class="docutils literal"><span class="pre">f0,</span> <span class="pre">f1,</span> <span class="pre">f2,</span> <span class="pre">f3...</span></code> (as in <code class="docutils literal"><span class="pre">f(x)</span></code>
above). Thus, for example, we can define a 4th-order power series
approximation <code class="docutils literal"><span class="pre">f</span></code> to <code class="docutils literal"><span class="pre">exp(x)=1+x+x**2/2+...</span></code> using</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">gvar.powerseries</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">PowerSeries</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mf">6.</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mf">24.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">f</span>             <span class="c"># print the coefficients</span>
<span class="go">[ 1.          1.          0.5         0.16666667  0.04166667]</span>
</pre></div>
</div>
<p>Arithmetic expressions involving instances of class <a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal"><span class="pre">PowerSeries</span></code></a> are
themselves <a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal"><span class="pre">PowerSeries</span></code></a> as in, for example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="mi">1</span><span class="o">/</span><span class="n">f</span>           <span class="c"># power series for exp(-x)</span>
<span class="go">[ 1.         -1.          0.5        -0.16666667  0.04166667]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">log</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>        <span class="c"># power series for x</span>
<span class="go">[ 0.  1.  0. -0.  0.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">f</span><span class="o">/</span><span class="n">f</span>           <span class="c"># power series for 1</span>
<span class="go">[ 1.  0.  0.  0.  0.]</span>
</pre></div>
</div>
<p>The standard arithmetic operators (<code class="docutils literal"><span class="pre">+,-,*,/,=,**</span></code>) are supported, as are
the usual elementary functions (<code class="docutils literal"><span class="pre">exp,</span> <span class="pre">log,</span> <span class="pre">sin,</span> <span class="pre">cos,</span> <span class="pre">tan</span> <span class="pre">...</span></code>). Different
<a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal"><span class="pre">PowerSeries</span></code></a> can be combined arithmetically to create new
<a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal"><span class="pre">PowerSeries</span></code></a>; the order of the result is that of the operand with the
lowest order.</p>
<p><a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal"><span class="pre">PowerSeries</span></code></a> can be differentiated and integrated:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">f</span><span class="o">.</span><span class="n">deriv</span><span class="p">()</span>     <span class="c"># derivative of exp(x)</span>
<span class="go">[ 1.          1.          0.5         0.16666667]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">f</span><span class="o">.</span><span class="n">integ</span><span class="p">()</span>     <span class="c"># integral of exp(x) (from x=0)</span>
<span class="go">[ 0.          1.          0.5         0.16666667  0.04166667  0.00833333]</span>
</pre></div>
</div>
<p>Each <a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal"><span class="pre">PowerSeries</span></code></a> represents a function. The <a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal"><span class="pre">PowerSeries</span></code></a> for
a function of a function is easily obtained. For example, assume <code class="docutils literal"><span class="pre">f</span></code>
represents function <code class="docutils literal"><span class="pre">f(x)=exp(x)</span></code>, as above, and <code class="docutils literal"><span class="pre">g</span></code>
represents <code class="docutils literal"><span class="pre">g(x)=log(1+x)</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">PowerSeries</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mf">3.</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mf">4.</span><span class="p">])</span>
</pre></div>
</div>
<p>Then <code class="docutils literal"><span class="pre">f(g)</span></code> gives the <a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal"><span class="pre">PowerSeries</span></code></a> for <code class="docutils literal"><span class="pre">exp(log(1+x))</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">x</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">f</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">[  1.0000e+00   1.0000e+00   0.0000e+00  -2.7755e-17 -7.6327e-17]</span>
</pre></div>
</div>
<p>Individual coefficients from the powerseries can be accessed using
array-element notation: for example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">1.0 1.0 0.5 0.166666666667</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">f</span>             <span class="c"># f is now the power series for exp(x)-1</span>
<span class="go">[ 0.          1.          0.5         0.16666667  0.04166667]</span>
</pre></div>
</div>
</div>
<div class="section" id="numerical-evaluation-of-power-series">
<h3>Numerical evaluation of power series<a class="headerlink" href="#numerical-evaluation-of-power-series" title="Permalink to this headline">¶</a></h3>
<p>The power series can also be evaluated for a particular
numerical value of x: continuing the example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>          <span class="c"># should be exp(0.01)-1 approximately</span>
<span class="go">0.0100501670833</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>      <span class="c"># verify that it is</span>
<span class="go">0.0100501670842</span>
</pre></div>
</div>
<p>The independent variable <code class="docutils literal"><span class="pre">x</span></code> could be of any arithmetic type (it need not
be a <code class="docutils literal"><span class="pre">float</span></code>).</p>
</div>
<div class="section" id="taylor-expansions-of-python-functions">
<h3>Taylor expansions of Python functions<a class="headerlink" href="#taylor-expansions-of-python-functions" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal"><span class="pre">PowerSeries</span></code></a> can be used to compute Taylor series for more-or-less
arbitrary pure-Python functions provided the functions are locally analytic
(or at least sufficiently differentiable). To compute the <code class="docutils literal"><span class="pre">N</span></code>-th order
expansion of a Python function <code class="docutils literal"><span class="pre">g(x)</span></code>, first create a <code class="docutils literal"><span class="pre">N</span></code>-th order
<a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal"><span class="pre">PowerSeries</span></code></a> variable that represents the expansion parameter: say,
<code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">PowerSeries([0.,1.],order=N)</span></code>. The Taylor series for function <code class="docutils literal"><span class="pre">g</span></code>
is then given by <code class="docutils literal"><span class="pre">g_taylor</span> <span class="pre">=</span> <span class="pre">g(x)</span></code> which is a <a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal"><span class="pre">PowerSeries</span></code></a> instance.
For example, consider:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">gvar.powerseries</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>           <span class="c"># an example of a Python function</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="mf">0.5</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">PowerSeries</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">],</span><span class="n">order</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>    <span class="c"># Taylor series for x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span>
<span class="go">[ 0.  1.  0.  0.  0.  0.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g_taylor</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>     <span class="c"># Taylor series for g(x) about x=0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">g_taylor</span>
<span class="go">[ 1.         0.         0.375      0.         0.2734375  0.       ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_taylor</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c"># Taylor series for exp(x) about x=0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">exp_taylor</span>
<span class="go">[ 1.          1.          0.5         0.16666667  0.04166667  0.00833333]</span>
</pre></div>
</div>
</div>
<dl class="class">
<dt id="gvar.powerseries.PowerSeries">
<em class="property">class </em><code class="descclassname">gvar.powerseries.</code><code class="descname">PowerSeries</code><span class="sig-paren">(</span><em>c=None</em>, <em>order=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.powerseries.PowerSeries" title="Permalink to this definition">¶</a></dt>
<dd><p>Power series representation of a function.</p>
<p>The power series created by <code class="docutils literal"><span class="pre">PowerSeries(c)</span></code> corresponds to:</p>
<div class="highlight-python"><div class="highlight"><pre>c[0] + c[1]*x + c[2]*x**2 + ... .
</pre></div>
</div>
<p>The order of the power series is normally determined by the length of
the input list <code class="docutils literal"><span class="pre">c</span></code>. This can be overridden by specifying the order of
the power series using the <code class="docutils literal"><span class="pre">order</span></code> parameter. The list of <code class="docutils literal"><span class="pre">c[i]</span></code>s
is then padded with zeros if <code class="docutils literal"><span class="pre">c</span></code> is too short, or truncated if it
is too long. Omitting <code class="docutils literal"><span class="pre">c</span></code> altogether results in a power series
all of whose coefficients are zero. Individual series
coefficients are accessed using array/list notation: for example,
the 3rd-order coefficient of <code class="docutils literal"><span class="pre">PowerSeries</span> <span class="pre">p</span></code> is <code class="docutils literal"><span class="pre">p[3]</span></code>. The
order of <code class="docutils literal"><span class="pre">p</span></code> is <code class="docutils literal"><span class="pre">p.order</span></code>. <a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal"><span class="pre">PowerSeries</span></code></a> should work
for coefficients of any data type that supports ordinary arithmetic.</p>
<p>Arithmetic expressions of <a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal"><span class="pre">PowerSeries</span></code></a> variables yield new
<a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal"><span class="pre">PowerSeries</span></code></a> results that represent the power series
expansion of the expression. Expressions can include the standard
mathematical functions (<code class="docutils literal"><span class="pre">log,</span> <span class="pre">exp,</span> <span class="pre">sqrt,</span> <span class="pre">sin,</span> <span class="pre">cos,</span> <span class="pre">tan...</span></code>).
<a class="reference internal" href="#gvar.powerseries.PowerSeries" title="gvar.powerseries.PowerSeries"><code class="xref py py-class docutils literal"><span class="pre">PowerSeries</span></code></a> can also be differentiated (<code class="docutils literal"><span class="pre">p.deriv()</span></code>)
and integrated (<code class="docutils literal"><span class="pre">p.integ()</span></code>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>c</strong> (<em>list or array</em>) &#8211; Power series coefficients (optional if parameter
<em>order</em> specified).</li>
<li><strong>order</strong> (<em>integer</em>) &#8211; Highest power in power series (optional if parameter
<em>c</em> specified).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gvar.powerseries.PowerSeries.__iter__">
<code class="descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gvar.powerseries.PowerSeries.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over coefficients of power series C{self}.</p>
</dd></dl>

<dl class="method">
<dt id="gvar.powerseries.PowerSeries.__setitem__">
<code class="descname">__setitem__</code><span class="sig-paren">(</span><em>i</em>, <em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.powerseries.PowerSeries.__setitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set C{i}th coefficient of power series equal to C{val}.</p>
</dd></dl>

<dl class="method">
<dt id="gvar.powerseries.PowerSeries.deriv">
<code class="descname">deriv</code><span class="sig-paren">(</span><em>n=1</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.powerseries.PowerSeries.deriv" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute <em>n</em>-th derivative of <code class="docutils literal"><span class="pre">self</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>n</strong> (<em>positive integer</em>) &#8211; Number of derivatives.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><em>n</em>-th derivative of <code class="docutils literal"><span class="pre">self</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gvar.powerseries.PowerSeries.integ">
<code class="descname">integ</code><span class="sig-paren">(</span><em>n=1</em>, <em>x0=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.powerseries.PowerSeries.integ" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute <em>n</em>-th indefinite integral of <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>If <em>x0</em> is specified, then the definite integral,
integrating from point <em>x0</em>, is returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>n</strong> (<em>integer</em>) &#8211; Number of integrations.</li>
<li><strong>x0</strong> &#8211; Starting point for definite integral (optional).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><em>n</em>-th integral of <code class="docutils literal"><span class="pre">self</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gvar.powerseries.PowerSeries.order">
<code class="descname">order</code><a class="headerlink" href="#gvar.powerseries.PowerSeries.order" title="Permalink to this definition">¶</a></dt>
<dd><p>Highest power in power series.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-gvar.root"></span></div>
<div class="section" id="root-finding">
<h2>Root Finding<a class="headerlink" href="#root-finding" title="Permalink to this headline">¶</a></h2>
<p>Module <a class="reference internal" href="#module-gvar.root" title="gvar.root: Roots (zeros) of one-dimensional functions."><code class="xref py py-mod docutils literal"><span class="pre">gvar.root</span></code></a> contains methods for finding the roots of
of one-dimensional functions: that is, finding <code class="docutils literal"><span class="pre">x</span></code> such that
<code class="docutils literal"><span class="pre">fcn(x)=0</span></code> for a given function <code class="docutils literal"><span class="pre">fcn</span></code>. Typical usage is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">math</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gvar</span> <span class="kn">as</span> <span class="nn">gv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">interval</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>     <span class="c"># bracket root</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>
<span class="go">(3.1384283767210035, 3.4522712143931042)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">refine</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="n">interval</span><span class="p">)</span>   <span class="c"># refine root</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="go">3.14159265359</span>
</pre></div>
</div>
<p>This code finds the first root of <code class="docutils literal"><span class="pre">sin(x)=0</span></code> larger than 1. The first
setp is a search to find an interval containing a root. Here
<a class="reference internal" href="#gvar.root.search" title="gvar.root.search"><code class="xref py py-meth docutils literal"><span class="pre">gvar.root.search()</span></code></a> examines <code class="docutils literal"><span class="pre">sin(x)</span></code> for a sequence of points
<code class="docutils literal"><span class="pre">1.</span> <span class="pre">*</span> <span class="pre">1.1</span> <span class="pre">**</span> <span class="pre">n</span></code> for <code class="docutils literal"><span class="pre">n=0,1,2...</span></code>, stopping when the function changes
sign. The last two points in the sequence then bracket a root
since <code class="docutils literal"><span class="pre">sin(x)</span></code> is continuous; they are returned as a tuple to <code class="docutils literal"><span class="pre">interval</span></code>.
The final root is found by refining the interval, using <code class="docutils literal"><span class="pre">gvar.root.refine</span></code>.
By default, the root is refined iteratively to machine precision, but this
requires only a small number (4) of iterations:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">nit</span><span class="p">)</span>                             <span class="c"># number of iterations</span>
<span class="go">4</span>
</pre></div>
</div>
<p>The most challenging situations are ones where the function
is extremely flat in the vicinity of the root &#8212; that is,
two or more of its leading derivatives vanish there. For
example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gvar</span> <span class="kn">as</span> <span class="nn">gv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">**</span> <span class="mi">11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">refine</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">nit</span><span class="p">)</span>                             <span class="c"># number of iterations</span>
<span class="go">142</span>
</pre></div>
</div>
<p>This routine also works with variables of type <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>:
for example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gvar</span> <span class="kn">as</span> <span class="nn">gv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">gv</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">refine</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="go">3.14(31)</span>
</pre></div>
</div>
<p>returns a root with a 10% uncertainty, reflecting the
uncertainty in parameter <code class="docutils literal"><span class="pre">w</span></code>.</p>
<p>Descriptions of the two methods follow.</p>
<dl class="method">
<dt id="gvar.root.search">
<code class="descclassname">root.</code><code class="descname">search</code><span class="sig-paren">(</span><em>fcn</em>, <em>x0</em>, <em>incr=0</em>, <em>fac=1.1</em>, <em>maxit=100</em>, <em>analyzer=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.root.search" title="Permalink to this definition">¶</a></dt>
<dd><p>Search for and bracket root of one-dimensional function <code class="docutils literal"><span class="pre">fcn(x)</span></code>.</p>
<p>This method searches for an interval in <code class="docutils literal"><span class="pre">x</span></code> that brackets
a root of <code class="docutils literal"><span class="pre">fcn(x)=0</span></code>. It examines points</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">fac</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">incr</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">x[0]=x0</span></code> and <code class="docutils literal"><span class="pre">j=0...maxit-1</span></code>, looking for a pair
of successive points where <code class="docutils literal"><span class="pre">fcn(x[j])</span></code> changes sign. These
points bracket a root (assuming the function is continuous),
providing a coarse estimate of the root. That estimate can
be refined using <code class="xref py py-meth docutils literal"><span class="pre">root.refine()</span></code>.</p>
<p class="rubric">Example</p>
<p>The following code seeks to bracket the first zero of
<code class="docutils literal"><span class="pre">sin(x)</span></code> with <code class="docutils literal"><span class="pre">x&gt;0.1</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">math</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gvar</span> <span class="kn">as</span> <span class="nn">gv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">interval</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>
<span class="go">(3.0912680532870755, 3.4003948586157833)</span>
</pre></div>
</div>
<p>The resulting interval correctly brackets the root
at <code class="docutils literal"><span class="pre">pi</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>fcn</strong> &#8211; One dimenionsal function whose root is sought.</li>
<li><strong>x0</strong> (<em>float</em>) &#8211; Starting point for search.</li>
<li><strong>incr</strong> (<em>float, optional</em>) &#8211; Increment used for linear searches. Default
value is 0.</li>
<li><strong>fac</strong> (<em>float, optional</em>) &#8211; Rescaling factor for exponential searches.
Default value is 1.1.</li>
<li><strong>maxit</strong> (<em>int, optional</em>) &#8211; Maximum number of steps allowed for search. An
exception is raised if a root is not found in time. Default
value is 100.</li>
<li><strong>analyzer</strong> &#8211; Optional function <code class="docutils literal"><span class="pre">f(x,</span> <span class="pre">fcn(x))</span></code> that is called
for each point <code class="docutils literal"><span class="pre">x</span></code> that is examined. This can be used,
for example, to monitor the search while debugging.
Default is <code class="docutils literal"><span class="pre">None</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p>Tuple <code class="docutils literal"><span class="pre">(a,</span> <span class="pre">b)</span></code> where <code class="docutils literal"><span class="pre">fcn(a)</span> <span class="pre">*</span> <span class="pre">fcn(b)</span> <span class="pre">&lt;=</span> <span class="pre">0</span></code>, which implies
that a root occurs between <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code> (provided the
function is continuous). The tuple has extra attributes
that provide additional information about the search:</p>
<ul class="simple">
<li><strong>nit</strong> &#8212; Number of iterations used to find interval <code class="docutils literal"><span class="pre">(a,b)</span></code>.</li>
<li><strong>fcnval</strong> &#8212; Tuple containing the function values at <code class="docutils literal"><span class="pre">(a,b)</span></code>.</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code> &#8211;
If unable to find a root in <code class="docutils literal"><span class="pre">maxit</span></code> steps.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gvar.root.refine">
<code class="descclassname">root.</code><code class="descname">refine</code><span class="sig-paren">(</span><em>fcn</em>, <em>interval</em>, <em>rtol=None</em>, <em>maxit=1000</em>, <em>analyzer=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gvar.root.refine" title="Permalink to this definition">¶</a></dt>
<dd><p>Find root <code class="docutils literal"><span class="pre">x</span></code> of one-dimensional function <code class="docutils literal"><span class="pre">fcn</span></code> on an interval.</p>
<p>This method finds a root <code class="docutils literal"><span class="pre">x</span></code> of <code class="docutils literal"><span class="pre">fcn(x)=0</span></code> inside an <code class="docutils literal"><span class="pre">interval=(a,b)</span></code>
that brackets the root, with <code class="docutils literal"><span class="pre">fcn(a)</span> <span class="pre">*</span> <span class="pre">fcn(b)</span> <span class="pre">&lt;=</span> <span class="pre">0</span></code>.</p>
<p>This method is a pure Python adaptation of an algorithm
from Richard Brent&#8217;s book &#8220;Algorithms for Minimization
without Derivatives&#8221; (1973). Being pure Python it works with
<a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a>-valued functions and variables.</p>
<p class="rubric">Example</p>
<p>The following code finds a root of <code class="docutils literal"><span class="pre">sin(x)</span></code> in the interval
<code class="docutils literal"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">4</span></code>, using 7 iterative refinements of the initial
interval:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">math</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gvar</span> <span class="kn">as</span> <span class="nn">gv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">refine</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="go">3.14159265359</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">nit</span><span class="p">)</span>
<span class="go">7</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>fcn</strong> &#8211; One-dimensional function whose zero/root is sought.</li>
<li><strong>interval</strong> &#8211; Tuple <code class="docutils literal"><span class="pre">(a,b)</span></code> specifying an interval containing
the root, with <code class="docutils literal"><span class="pre">fcn(a)</span> <span class="pre">*</span> <span class="pre">fcn(b)</span> <span class="pre">&lt;=</span> <span class="pre">0</span></code>. The search
for a root is confined to this interval.</li>
<li><strong>rtol</strong> (<em>float, optional</em>) &#8211; Relative tolerance for the root. The default
value is <code class="docutils literal"><span class="pre">None</span></code>, which sets <code class="docutils literal"><span class="pre">rtol</span></code> equal to machine
precision (<code class="docutils literal"><span class="pre">sys.float_info.epsilon</span></code>). A larger value
usually leads to less precision but is faster.</li>
<li><strong>maxit</strong> (<em>int, optional</em>) &#8211; Maximum number of iterations used to find
a root with the given tolerance. A warning is
issued if the algorithm does not converge in time.
(Default value is 1000.)</li>
<li><strong>analyzer</strong> &#8211; Optional function <code class="docutils literal"><span class="pre">f(x,</span> <span class="pre">fcn(x))</span></code> that is called
for each point <code class="docutils literal"><span class="pre">x</span></code> examined by the algorithm. This can
be used, for example, to monitor convergence while
debugging. Default is <code class="docutils literal"><span class="pre">None</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p>The root, which is either a <code class="docutils literal"><span class="pre">float</span></code> or
a <a class="reference internal" href="gvar.html#gvar.GVar" title="gvar.GVar"><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code></a> but with extra attributes that
provide additional information about the root:</p>
<ul class="simple">
<li><strong>nit</strong> &#8212; Number of iterations used to find the root.</li>
<li><strong>interval</strong> &#8212; Smallest interval <code class="docutils literal"><span class="pre">(b,c)</span></code> found containing
the root, where <code class="docutils literal"><span class="pre">b</span></code> is the root returned by the method.</li>
<li><strong>fcnval</strong> &#8212; Value of <code class="docutils literal"><span class="pre">fcn(x)</span></code> at the root.</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code> &#8211;
If <code class="docutils literal"><span class="pre">fcn(a)</span> <span class="pre">*</span> <span class="pre">fcn(b)</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> for initial
interval <code class="docutils literal"><span class="pre">(a,b)</span></code>.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">UserWarning</span></code> &#8211;
If the algorithm fails to converge
after <code class="docutils literal"><span class="pre">maxit</span></code> iterations.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Numerical Analysis Modules in <code class="docutils literal"><span class="pre">gvar</span></code></a><ul>
<li><a class="reference internal" href="#cubic-splines">Cubic Splines</a></li>
<li><a class="reference internal" href="#linear-algebra">Linear Algebra</a></li>
<li><a class="reference internal" href="#ordinary-differential-equations">Ordinary Differential Equations</a></li>
<li><a class="reference internal" href="#one-dimensional-integration">One-Dimensional Integration</a></li>
<li><a class="reference internal" href="#module-gvar.powerseries">Power Series</a><ul>
<li><a class="reference internal" href="#power-series-arithmetic">Power series arithmetic</a></li>
<li><a class="reference internal" href="#numerical-evaluation-of-power-series">Numerical evaluation of power series</a></li>
<li><a class="reference internal" href="#taylor-expansions-of-python-functions">Taylor expansions of Python functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#root-finding">Root Finding</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="gvar_dataset.html"
                        title="previous chapter"><code class="docutils literal"><span class="pre">gvar.dataset</span></code> - Random Data Sets</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="case-pendulum.html"
                        title="next chapter">Case Study: Pendulum Clock</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="case-pendulum.html" title="Case Study: Pendulum Clock"
             >next</a> |</li>
        <li class="right" >
          <a href="gvar_dataset.html" title="gvar.dataset - Random Data Sets"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">gvar 8.3.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2009-2015, G. P. Lepage.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>